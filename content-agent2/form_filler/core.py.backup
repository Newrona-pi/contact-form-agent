from __future__ import annotations

import asyncio
import csv
import json
import logging
import os
import re
from datetime import datetime
from typing import Any, Dict, List, Optional, Tuple
from urllib.parse import urlparse

import aiofiles
import aiolimiter
import yaml
from playwright.async_api import async_playwright, Page
from playwright.async_api import TimeoutError as PlaywrightTimeoutError
from bs4 import BeautifulSoup, Tag

from .models import FormTask, FormResult
from .constants import (
    CANDIDATES,
    FILLABLE_KEYS,
    PRIORITY_KEYS,
    SPECIAL_MIN_SCORE,
    LEARN_STOPWORDS,
    DEFAULT_LEXICON_BASE,
    DEFAULT_LEXICON_CUSTOM,
    # 追記（カスケード判定用）
    STRONG_TOKENS,
    CONFIRM_TOKENS,
    SEARCH_TOKENS,
    HONEYPOT_TOKENS,
    ADDRESS_TOKENS,
    AUTOCOMPLETE_MAP,
    # 企業/個人分岐検出用
    CORP_TABS_TOKENS,
    PERSON_TABS_TOKENS,
    CORP_FIELD_TOKENS,
    PERSON_FIELD_TOKENS,
)
from .utils import normalize, css_escape, split_name, split_phone
from .selectors import (
    selector_for,
    selector_for_locator,
    get_label_text_for_locator,
    extract_label_text,
    # 追記：一括抽出
    extract_labels_bulk,
    fallback_fill_textarea,  # NEW: 汎用textarea救済
    # デモ可視化の前にスクロール
)
from .filling import scroll_into_view  # 可視化時に利用
from .captcha import CaptchaHandler
from .consent import (
    ensure_acceptance,
    try_check_any_non_consent_checkbox,
    choose_second_option_in_form,
    ensure_required_radio_groups,
)


logger = logging.getLogger(__name__)


def is_ad_or_analytics(url: str) -> bool:
    """広告・解析系ドメインかどうかを判定する"""
    url_lower = url.lower()
    ad_analytics_domains = [
        "googletagmanager.com",
        "google-analytics.com",
        "analytics.google.com",
        "doubleclick.net",
        "facebook.net",
        "connect.facebook.net",
        "hotjar.com",
        "mixpanel.com",
        "segment.io",
        "sentry.io",
        "bat.bing.com",
        "criteo.com",
        "newrelic.com",
    ]
    return any(domain in url_lower for domain in ad_analytics_domains)


def is_form_helper(url: str) -> bool:
    """フォーム機能に必要なドメインかどうかを判定する"""
    url_lower = url.lower()
    form_helper_domains = [
        "www.google.com/recaptcha",
        "www.gstatic.com/recaptcha",
        "challenges.cloudflare.com",
        "hcaptcha.com",
        "js.stripe.com",
        "pay.stripe.com",
        "paypal.com",
        "paypalobjects.com",
    ]
    return any(domain in url_lower for domain in form_helper_domains)


class FormFillerCore:
    """フォーム自動入力のコアロジッククラス"""

    # 企業パネルCSSを全処理で使い回す（find_all_field_matches で確定）
    _corp_scope_selector: Optional[str] = None

    async def _resolve_corp_scope_by_controls(self, page) -> str | None:
        """
        1) 「企業/法人/会社…」コントロール要素を探す
        2) aria-controls / data-target / href(#id) で"パネル候補"を取得
        3) パネル候補を『企業パネル全体』に正規化（小さすぎる span/p を祖先へ持ち上げ）
        4) その CSS パスを返す（見つからなければ None）
        """
        js = r"""
        (() => {
          const txtRe = /(企業|法人|会社|法人[／/・]団体|企業の方|法人の方)/;
          const controls = Array.from(document.querySelectorAll(
            '[role="tab"], [aria-controls], [data-target], a[href^="#"], button, label'
          )).filter(el => txtRe.test((el.textContent || "").replace(/\s+/g,"")));
          const getPanel = (el) => {
            let sel = el.getAttribute('aria-controls') || el.getAttribute('data-target') || '';
            if (!sel) {
              const href = el.getAttribute('href') || '';
              if (href && href.startsWith('#')) sel = href;
            }
            if (!sel) return null;
            try {
              const panel = sel.startsWith('#') ? document.querySelector(sel) : document.querySelector(sel);
              return panel || null;
            } catch { return null; }
          };

          const totalInputs = (node) => node ? node.querySelectorAll('input,textarea,select').length : 0;
          const countCorp = (node) => node ? node.querySelectorAll(
            'select[name="company_inquiry_type"], input[name="company_name"], input[name="company_email"], textarea[name="company_your_message"], [name^="company_"], [id^="company_"]'
          ).length : 0;
          const hasPersonal = (node) => node ? !!node.querySelector('[name^="personal_"], [id^="personal_"]') : false;

          const normalizePanel = (panel) => {
            if (!panel) return null;
            const form = panel.closest('form') || document;
            // panel を含む祖先候補（form 配下のブロック要素）を列挙
            const blocks = Array.from(form.querySelectorAll('div,section,fieldset,article'));
            let cand = blocks.filter(b => b.contains(panel));
            // 企業のまとまりと判断できる最小祖先：企業キー>=2、personalなし、入力数>=5
            cand = cand.filter(b => countCorp(b) >= 2 && !hasPersonal(b) && totalInputs(b) >= 5);
            if (cand.length) {
              // 企業キー多い順 → 入力数多い順 → panel に近い順（より"まとまり"に近い）
              const depth = (el) => { let d=0; for (let n=el; n; n=n.parentElement) d++; return d; };
              cand.sort((a,b) => {
                const cB = countCorp(b) - countCorp(a);
                if (cB) return cB;
                const tB = totalInputs(b) - totalInputs(a);
                if (tB) return tB;
                return depth(b) - depth(a); // 近い方（深い方）を優先
              });
              return cand[0];
            }
            // 条件を満たさない場合は、panel 自体を返す（後段の fallback に委ねる）
            return panel;
          };
          const cssPath = (el) => {
            if (!el) return null;
            if (el.id) return '#'+CSS.escape(el.id);
            const parts = [];
            for (let n=el; n && n.nodeType===1 && n!==document; n=n.parentElement) {
              if (n.id) { parts.unshift('#'+CSS.escape(n.id)); break; }
              const tn = n.tagName.toLowerCase();
              let i=1, s=n;
              while ((s=s.previousElementSibling)) if (s.tagName && s.tagName.toLowerCase()===tn) i++;
              parts.unshift(`${tn}:nth-of-type(${i})`);
            }
            return parts.join(' > ');
          };
          for (const el of controls) {
            const panel0 = getPanel(el);
            if (!panel0) continue;
            const panel = normalizePanel(panel0);
            if (panel && countCorp(panel) >= 2 && !hasPersonal(panel) && totalInputs(panel) >= 5) {
              return cssPath(panel);
            }
          }
          // フォールバック：代表フィールドから祖先を正規化
          const anchor = document.querySelector('select[name="company_inquiry_type"], input[name="company_name"], input[name="company_email"], textarea[name="company_your_message"], [name^="company_"], [id^="company_"]');
          if (!anchor) return null;
          const norm = normalizePanel(anchor);
          return cssPath(norm);
        })();
        """
        try:
            return await page.evaluate(js)
        except Exception:
            return None

    async def _css_path(self, page, handle_selector: str) -> str | None:
        js = r"""
        (sel) => {
          const el = document.querySelector(sel);
          if (!el) return null;
          if (el.id) return '#'+CSS.escape(el.id);
          const parts=[];
          let n = el;
          while (n && n.nodeType===1 && n!==document){
            if (n.id){ parts.unshift('#'+CSS.escape(n.id)); break; }
            const tn=n.tagName.toLowerCase(); let i=1, s=n;
            while ((s=s.previousElementSibling)) if (s.tagName && s.tagName.toLowerCase()===tn) i++;
            parts.unshift(`${tn}:nth-of-type(${i})`);
            n=n.parentElement;
          }
          return parts.join(' > ');
        }
        """
        try:
            return await page.evaluate(js, handle_selector)
        except Exception:
            return None

    async def _is_visible(self, page, selector: str) -> bool:
        js = r"""
        (sel) => {
          const el = document.querySelector(sel);
          if (!el) return false;
          const cs = getComputedStyle(el);
          if (!cs) return false;
          if (cs.display === 'none' || cs.visibility === 'hidden' || parseFloat(cs.opacity || '1') === 0) return false;
          const r = el.getClientRects();
          return !!(r && r.length > 0);
        }
        """
        try:
            return await page.evaluate(js, selector)
        except Exception:
            return False

    async def _is_really_visible(self, page, selector: str) -> bool:
        js = r"""
        (sel) => {
          const el = document.querySelector(sel);
          if (!el) return false;
          const visibleInTree = (n) => {
            while (n && n.nodeType === 1) {
              const cs = getComputedStyle(n);
              if (n.hasAttribute('hidden') || n.getAttribute('aria-hidden') === 'true') return false;
              if (cs.display === 'none' || cs.visibility === 'hidden' || parseFloat(cs.opacity) === 0) return false;
              n = n.parentElement;
            }
            return true;
          };
          if (!visibleInTree(el)) return false;
          if (el.offsetParent === null) return false;
          const r = el.getBoundingClientRect();
          if (r.width === 0 || r.height === 0) return false;
          const vw = (window.innerWidth || document.documentElement.clientWidth);
          const vh = (window.innerHeight || document.documentElement.clientHeight);
          if (r.right <= 0 || r.bottom <= 0 || r.left >= vw || r.top >= vh) return false;
          return true;
        }
        """
        try:
            return await page.evaluate(js, selector)
        except Exception:
            return False

    async def _resolve_corp_form_scope(self, page: Page) -> Optional[str]:
        """
        企業フォームの実フィールドが 'controls' ラッパー外にあるケースに対応するため、
        「企業アンカー要素を含む <form>」をスコープとして返す。見つからなければ None。
        """
        anchors = [
            'select[name="company_inquiry_type"]',
            'textarea[name="company_your_message"]',
            'input[name="company_email"]',
            '#company_tel1',
            '#company_tel2',
            '#company_tel3',
        ]
        for a in anchors:
            try:
                loc = page.locator(f'form:has({a})').first
                if await loc.count():
                    return f'form:has({a})'
            except Exception:
                continue
        return None

    async def _build_mode_partitions(self, page: Page, form_scope: Optional[str]) -> Optional[dict]:
        """
        個人/企業の切替ロジックを“実際に”適用し、可用フィールド集合の差分で
        company_only / personal_only / shared を厳密に確定する。
        """
        if not form_scope:
            return None
        try:
            await self._ensure_mode(page, target="company")
            corp = await self._snapshot_active_field_keys(page, form_scope)
            await self._ensure_mode(page, target="personal")
            pers = await self._snapshot_active_field_keys(page, form_scope)
        finally:
            await self._ensure_mode(page, target="company")
        company_only = corp - pers
        personal_only = pers - corp
        shared = corp & pers
        return {"company_only": company_only, "personal_only": personal_only, "shared": shared}

    async def _snapshot_active_field_keys(self, page: Page, scope_selector: str) -> set:
        """
        scope 内の input/select/textarea のうち、内部ロジックにより“現在有効”な要素の
        安定キー集合（name/id/簡易CSSパス）を返す。
        """
        js = r"""
        (scopeSel) => {
          const root = document.querySelector(scopeSel);
          if (!root) return [];
          const isHiddenByLogic = (el) => {
            if (el.closest('[hidden]')) return true;
            if (el.closest('[aria-hidden="true"]')) return true;
            if (el.closest('.wpcf7cf-hidden, .is-hidden, .u-hidden, .is-none, .hidden')) return true;
            const style = window.getComputedStyle(el);
            if (style.display === 'none' || style.visibility === 'hidden' || parseFloat(style.opacity) === 0) return true;
            if (el.offsetParent === null && style.position !== 'fixed') return true;
            return false;
          };
          const cssPath = (el) => {
            if (el.id) return `#${el.id}`;
            const segs = [];
            let e = el;
            while (e && e.nodeType === 1 && e !== root) {
              if (e.id) { segs.unshift(`#${e.id}`); break; }
              const tag = e.tagName.toLowerCase();
              let i = 1, s = e;
              while ((s = s.previousElementSibling) != null) if (s.tagName === e.tagName) i++;
              segs.unshift(`${tag}:nth-of-type(${i})`);
              e = e.parentElement;
            }
            return segs.join(' > ');
          };
          const els = root.querySelectorAll('input, select, textarea');
          const out = new Set();
          els.forEach(el => {
            if (el.disabled) return;
            if (isHiddenByLogic(el)) return;
            const key = el.getAttribute('name') || el.id || cssPath(el);
            out.add(key);
          });
          return Array.from(out);
        }
        """
        keys = await page.evaluate(js, scope_selector)
        return set(keys or [])

    async def _ensure_mode(self, page: Page, target: str = "company") -> None:
        """
        企業/個人の切替 UI をできるだけ網羅的に探してクリックする。
        見つからなければ何もしない（現状維持）。
        """
        if target == "company":
            cands = [
                'role=tab[name=/法人|企業|会社/]',
                'button:has-text("法人")', 'button:has-text("企業")', 'button:has-text("会社")',
                'a:has-text("法人の方")', 'a:has-text("企業の方")',
                'input[type="radio"][value*="法人"]', 'input[type="radio"][value*="企業"]',
                '[data-tab="company"], [data-mode="company"], .js-company',
            ]
        else:
            cands = [
                'role=tab[name=/個人|パーソナル/]',
                'button:has-text("個人")', 'button:has-text("パーソナル")',
                'a:has-text("個人の方")',
                'input[type="radio"][value*="個人"]',
                '[data-tab="personal"], [data-mode="personal"], .js-personal',
            ]
        for sel in cands:
            try:
                loc = page.locator(sel).first
                if await loc.count():
                    await loc.click()
                    await page.wait_for_timeout(250)
                    return
            except Exception:
                continue
        return

    async def _stable_key_of(self, elem_selector: str) -> str:
        """
        入力対象要素から安定キー（name / id / 簡易CSSパス）を得る。
        """
        js = r"""
        (sel) => {
          const el = document.querySelector(sel);
          if (!el) return sel;
          return el.getAttribute('name') || el.id || sel;
        }
        """
        try:
            return await self.page.evaluate(js, elem_selector)
        except Exception:
            return elem_selector

    async def _looks_personal(self, page, selector: str) -> bool:
        js = r"""
        (sel) => {
          const el = document.querySelector(sel);
          if (!el) return false;
          const re = /(personal|private|kojin|個人)/i;
          let n = el;
          while (n && n.nodeType === 1) {
            const tokens = ((n.id||'') + ' ' + (n.getAttribute('name')||'') + ' ' + (n.className||''))\
              .toLowerCase();
            if (re.test(tokens)) return true;
            n = n.parentElement;
          }
          return false;
        }
        """
        try:
            return await page.evaluate(js, selector)
        except Exception:
            return False

    async def _resolve_corp_scope_exclusive_panel(self, page) -> str | None:
        """
        company系アンカー群の最小共通祖先(LCA)を取り、personal系を含まない最小祖先を
        「企業用パネル」として返す。見つからなければ None。
        """
        js = r"""
        () => {
          const qs = (s) => Array.from(document.querySelectorAll(s));
          const corp = qs('[name^="company_"],[name*="company_"],[id^="company_"],[id*="company_"],[class*="company"]');
          if (corp.length < 2) return null;
          const hasPersonal = (node) => !!node.querySelector('[id^="personal_"],[id*="personal_"],[name^="personal_"],[name*="personal_"],[class*="personal"]');
          const lca = (a,b) => {
            if (!a || !b) return null;
            const path = (n) => { const arr=[]; while(n){arr.unshift(n); n=n.parentElement;} return arr; };
            const pa = path(a), pb = path(b);
            let i=0, last=null;
            while (i<pa.length && i<pb.length && pa[i]===pb[i]) { last = pa[i]; i++; }
            return last;
          };
          let node = corp[0];
          for (let i=1; i<corp.length; i++){ node = lca(node, corp[i]) || node; }
          if (!node) return null;
          while (node && hasPersonal(node)) node = node.parentElement;
          if (!node) return null;
          const cssPath = (el) => {
            if (!el) return null;
            if (el.id) return '#'+CSS.escape(el.id);
            const parts=[]; let n=el;
            while (n && n.nodeType===1 && n!==document) {
              if (n.id){ parts.unshift('#'+CSS.escape(n.id)); break; }
              const tn=n.tagName.toLowerCase(); let i=1, s=n;
              while ((s=s.previousElementSibling)) if (s.tagName && s.tagName.toLowerCase()===tn) i++;
              parts.unshift(`${tn}:nth-of-type(${i})`);
              n=n.parentElement;
            }
            return parts.join(' > ');
          };
          return cssPath(node);
        }
        """
        try:
            const_selector = await page.evaluate(js)
            if const_selector and getattr(self, "debug", False):
                logger.debug(f"[corp-scope-panel] scope={const_selector}")
            return const_selector
        except Exception:
            return None

    async def _within_scope(self, page, scope_selector: str | None, selector: str) -> bool:
        """
        selector で指す要素が scope_selector（企業用パネル）配下に厳密に属するかを判定。
        scope 未指定なら True。
        """
        if not scope_selector:
            return True
        js = r"""
        (sc, sel) => {
          const root = document.querySelector(sc);
          const el = document.querySelector(sel);
          return !!(root && el && root.contains(el));
        }
        """
        try:
            return await page.evaluate(js, scope_selector, selector)
        except Exception:
            return False

    async def _drop_personal_prefixed(self, page, selector: str) -> bool:
        """
        selector の要素が personal 系プレフィックス（id/name が ^personal[_-] 等）なら除外。
        True を返したら「除外」扱い。
        """
        js = r"""
        (sel) => {
          const el = document.querySelector(sel);
          if (!el) return false;
          const nm = (el.getAttribute('name') || '');
          const id = (el.id || '');
          const re = /^(personal|private|individual)[_-]/i;
          return re.test(nm) || re.test(id);
        }
        """
        try:
            return await page.evaluate(js, selector)
        except Exception:
            return False

    async def _filter_candidates_in_scope(self, page, scope_selector: str | None, cands: list[dict], key: str | None = None) -> list[dict]:
        """
        候補を企業スコープ配下・personal除外・非表示除外にふるい込む
        """
        kept: list[dict] = []
        for c in cands or []:
            sel = c.get("selector") if isinstance(c, dict) else None
            if not sel:
                continue
            # 企業スコープ外は除外
            if not await self._within_scope(page, scope_selector, sel):
                if getattr(self, "debug", False):
                    logger.debug(f"[SCOPED-GUARD] drop(outside) selector={sel}")
                continue
            # 個人用トークンを含むものは除外（安全弁）
            if await self._looks_personal(page, sel):
                if getattr(self, "debug", False):
                    logger.debug(f"[SCOPED-GUARD] drop(personal) selector={sel}")
                continue
            # 明らかな意味不一致の除外（名前系に tel/phone を混入させない）
            if key in {"name", "first_name", "last_name", "nameSei", "nameMei"}:
                try:
                    meta = await page.evaluate(
                        "(sel)=>{const el=document.querySelector(sel);return {id:el?.id||'',name:el?.getAttribute('name')||'',type:(el?.getAttribute('type')||'').toLowerCase()};}",
                        sel
                    )
                    iname = (meta.get('id','') + ' ' + meta.get('name','')).lower()
                    if 'tel' in iname or 'phone' in iname or meta.get('type') == 'tel':
                        if getattr(self, "debug", False):
                            logger.debug(f"[SCOPED-GUARD] drop(mismatch-name↔tel) selector={sel}")
                        continue
                except Exception:
                    pass
            # 非表示は候補から外す（hidden panel への誤爆防止）
            if not await self._is_really_visible(page, sel):
                if getattr(self, "debug", False):
                    logger.debug(f"[SCOPED-GUARD] drop(hidden) selector={sel}")
                continue
            kept.append(c)
        return kept


class FormFiller(FormFillerCore):
    """フォーム自動入力クラス"""

    def __init__(
        self,
        concurrency: int = 1,
        timeout: int = 8,
        captcha_api: str = "anticaptcha",
        dry_run: bool = False,
        no_submit: bool = False,
        fast_mode: bool = False,
        learn: bool = False,
        learn_out: str = os.path.join("lexicon", "suggestions.csv"),
        lexicon: Optional[str] = None,
        dump_lexicon: bool = False,
        show_browser: bool = False,
        debug: bool = False,
        demo_ms: int = 0,
    ):
        self.concurrency = concurrency
        self.timeout = timeout
        self.captcha_api = captcha_api
        self.dry_run = dry_run
        self.no_submit = no_submit or learn
        self.fast_mode = fast_mode
        self.learn = learn
        self.learn_out = learn_out
        self.lexicon_path = lexicon
        self.dump_lexicon = dump_lexicon
        # レート制限: グローバル + ドメイン別（12/min）
        self.global_limiter = aiolimiter.AsyncLimiter(60, 60)
        self._domain_limiters: dict[str, aiolimiter.AsyncLimiter] = {}
        self.results: List[FormResult] = []
        self.show_browser = show_browser
        self.debug = debug
        self.demo_ms = int(demo_ms) if demo_ms and int(demo_ms) > 0 else 0
        self._file_lock = asyncio.Lock()
        self._learn_lock = asyncio.Lock()
        self._learn_seen: set[tuple[str, str, str, str]] = set()

        try:
            self._load_lexicon()
        except Exception as e:
            logger.debug(f"lexicon読み込みスキップ/失敗: {e}")

        if self.dump_lexicon:
            try:
                self._dump_lexicon()
            except Exception:
                pass

        self.captcha_handler = None

        # 追記：STRONG_TOKENS をコンパイル
        self._compiled_strong: Dict[str, List[re.Pattern]] = {}
        for k, pats in (STRONG_TOKENS or {}).items():
            out = []
            for p in pats:
                try:
                    out.append(re.compile(p, re.I))
                except Exception:
                    out.append(re.compile(re.escape(str(p)), re.I))
            self._compiled_strong[k] = out

        # 確認欄判定用トークン（事前コンパイル）
        self._confirm_pat = re.compile("|".join([re.escape(x) for x in CONFIRM_TOKENS]), re.I) if CONFIRM_TOKENS else None
        # 検索欄除外
        self._search_pat = re.compile("|".join([re.escape(x) for x in SEARCH_TOKENS]), re.I) if SEARCH_TOKENS else None
        # honeypot判定
        self._honeypot_pat = re.compile("|".join([re.escape(x) for x in HONEYPOT_TOKENS]), re.I) if HONEYPOT_TOKENS else None

    def _domain_limiter(self, form_url: str) -> aiolimiter.AsyncLimiter:
        """ドメイン別のレートリミッタ（12/min）を取得"""
        try:
            host = urlparse(form_url).hostname or "default"
        except Exception:
            host = "default"
        if host not in self._domain_limiters:
            self._domain_limiters[host] = aiolimiter.AsyncLimiter(12, 60)
        return self._domain_limiters[host]

    def _compile_regex_dict(self, raw: Dict[str, List[str]]) -> Dict[str, List[re.Pattern]]:
        compiled: Dict[str, List[re.Pattern]] = {}
        for key, patterns in raw.items():
            out: List[re.Pattern] = []
            for pat in patterns or []:
                try:
                    out.append(re.compile(pat, re.I))
                except Exception:
                    out.append(re.compile(re.escape(str(pat)), re.I))
            compiled[key] = out
        return compiled

    def _load_yaml_if_exists(self, path: str) -> Dict[str, List[str]]:
        try:
            if path and os.path.exists(path):
                with open(path, "r", encoding="utf-8") as f:
                    data = yaml.safe_load(f) or {}
                if isinstance(data, dict):
                    return {str(k): (list(v) if isinstance(v, list) else [str(v)]) for k, v in data.items()}
        except Exception as e:
            logger.debug(f"lexiconファイル読み込み失敗: {path}: {e}")
        return {}

    def _load_lexicon(self) -> None:
        global CANDIDATES, FILLABLE_KEYS
        base = self._load_yaml_if_exists(DEFAULT_LEXICON_BASE)
        custom = self._load_yaml_if_exists(DEFAULT_LEXICON_CUSTOM)
        extra = self._load_yaml_if_exists(self.lexicon_path) if self.lexicon_path else {}

        merged: Dict[str, List[str]] = {}
        for k, v in CANDIDATES.items():
            merged[k] = [*v]
        for src in (base, custom, extra):
            for k, v in src.items():
                if k in merged:
                    merged[k].extend([x for x in v if x not in merged[k]])
                else:
                    merged[k] = [*v]

        CANDIDATES = self._compile_regex_dict(merged)

        ext_keys: set[str] = set(FILLABLE_KEYS)
        for src in (base, custom, extra):
            for k in src.keys():
                ext_keys.add(k)
        FILLABLE_KEYS.clear()
        for k in sorted(ext_keys):
            FILLABLE_KEYS.add(k)

    def _dump_lexicon(self) -> None:
        from typer import echo

        echo("=== Dump Lexicon ===")
        for k in sorted(CANDIDATES.keys()):
            pats = CANDIDATES[k]
            shown = [p.pattern if hasattr(p, "pattern") else str(p) for p in pats]
            echo(f"{k}: {shown}")

    # ========== ここから：新規 即決カスケード用ヘルパ ==========

    @staticmethod
    def _norm(s: Optional[str]) -> str:
        return (s or "").strip()

    def _textbag(self, f: Dict[str, Any]) -> str:
        # ラベル/placeholder/aria/name/id/class を1つの文字列に
        parts = [
            f.get("labelText") or "",
            f.get("placeholder") or "",
            f.get("ariaLabel") or "",
            f.get("name") or "",
            f.get("id") or "",
            f.get("class") or "",
        ]
        return " ".join([p for p in parts if p]).lower()

    def _search_like(self, f: Dict[str, Any]) -> bool:
        if not self._search_pat:
            return False
        return bool(self._search_pat.search(self._textbag(f)))

    def _honeypot_like(self, f: Dict[str, Any]) -> bool:
        """不可視かつ honeypot語を含む場合に除外（安全側）"""
        if not getattr(self, "_honeypot_pat", None):
            return False
        try:
            return (not f.get("visible")) and bool(self._honeypot_pat.search(self._textbag(f)))
        except Exception:
            return False

    def _match_strong(self, key: str, text: str) -> bool:
        pats = self._compiled_strong.get(key) or []
        for p in pats:
            if p.search(text):
                return True
        return False

    def _match_placeholder_exact(self, key: str, text: str) -> bool:
        """placeholder専用の完全一致判定"""
        # 強トークンのリストを取得
        strong_tokens = STRONG_TOKENS.get(key, [])
        
        # 各トークンについて完全一致をチェック
        for token in strong_tokens:
            # 正規表現パターンの場合は完全一致でチェック
            if token.startswith('r"') or token.startswith("r'"):
                # 正規表現パターンから実際のパターンを抽出
                pattern = token[2:-1]  # r"..." から ... を抽出
                if re.fullmatch(pattern, text):  # ← fullmatchで完全一致
                    return True
            else:
                # 通常の文字列の場合は完全一致
                if token == text:  # ← == で完全一致
                    return True
        
        # CANDIDATESのパターンも完全一致でチェック
        candidates = CANDIDATES.get(key, [])
        for pattern in candidates:
            if re.fullmatch(pattern, text):  # ← fullmatchで完全一致
                return True
        
        return False

    # ========= 可視デモ支援（show_browser時のみ動作） =========
    async def _ensure_demo_css(self, page: Page) -> None:
        if getattr(self, "_demo_css_injected", False):
            return
        css = """
        .ff-tip{
          position: fixed; z-index: 2147483647; font: 12px/1.4 -apple-system, BlinkMacSystemFont, Segoe UI, sans-serif;
          background: rgba(0,0,0,.80); color: #fff; padding: 6px 8px; border-radius: 8px; pointer-events:none;
          box-shadow: 0 2px 8px rgba(0,0,0,.35);
        }
        .ff-pulse{
          outline: 3px solid #1fd2ff !important; transition: outline 120ms ease;
          box-shadow: 0 0 0 4px rgba(31,210,255,.25) !important;
        }
        .ff-ok{
          outline: 3px solid #22c55e !important;
          box-shadow: 0 0 0 4px rgba(34,197,94,.25) !important;
          transition: outline 120ms ease;
        }
        """
        try:
            await page.add_style_tag(content=css)
            self._demo_css_injected = True
        except Exception:
            pass

    async def _demo_flash(self, page: Page, locator, key: str, preview: str) -> None:
        if not (self.show_browser and self.demo_ms):
            return
        try:
            await self._ensure_demo_css(page)
            # 元素にパルス、吹き出し表示、視界に入れる
            await scroll_into_view(locator)
            await locator.evaluate("(el)=>{ el.classList.add('ff-pulse'); }")
            # 吹き出しを要素の右上あたりに
            await page.evaluate("""
                (args)=>{
                  const {sel,key,val,ms}=args;
                  const el = document.querySelector(sel);
                  if(!el) return;
                  const r = el.getBoundingClientRect();
                  const tip = document.createElement('div');
                  tip.className='ff-tip';
                  tip.textContent = key + ': ' + val;
                  tip.style.left = Math.min(window.innerWidth-260, Math.max(8, r.right + 8)) + 'px';
                  tip.style.top  = Math.max(8, r.top - 6) + 'px';
                  document.body.appendChild(tip);
                  setTimeout(()=> tip.remove(), Math.min(2000, ms+400));
                }
            """, {
                "sel": await locator.evaluate("el=>{ if(el.id) return '#'+el.id; const tn=el.tagName.toLowerCase(); return tn; }"),
                "key": key, "val": preview, "ms": self.demo_ms
            })
        except Exception:
            pass

    async def _demo_mark_ok(self, locator) -> None:
        if not (self.show_browser and self.demo_ms):
            return
        try:
            await locator.evaluate("(el)=>{ el.classList.remove('ff-pulse'); el.classList.add('ff-ok'); setTimeout(()=>el.classList.remove('ff-ok'), 650); }")
        except Exception:
            pass

    def _is_confirm_like_for_base(self, f: Dict[str, Any], base_key: str) -> bool:
        """
        確認欄（email_confirm等）の判定。
        - confirmトークンが含まれている
        - 同時に base_key（email/phone等）の強トークン or type/autocomplete が合う
        """
        tb = self._textbag(f)
        if self._confirm_pat and self._confirm_pat.search(tb):
            # base の同定（type/autocomplete/強トークン）
            if base_key == "email":
                if (f.get("type") == "email") or (f.get("autocomplete", "").lower() == "email") or self._match_strong("email", tb):
                    return True
            if base_key == "phone":
                if (f.get("type") == "tel") or (f.get("autocomplete", "").lower() in ("tel", "phone")) or self._match_strong("phone", tb):
                    return True
        # name/id に conf 系接尾辞
        name_id = f"{f.get('name','')} {f.get('id','')}".lower()
        if base_key == "email" and re.search(r"(email.*(conf|confirm|retype|again)|mail.*(conf|confirm))", name_id):
            return True
        if base_key == "phone" and re.search(r"(phone|tel).*(conf|confirm|retype|again)", name_id):
            return True
        return False

    def _tie_break(self, matches: List[Dict[str, Any]], prefer_tag: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """同点対処：required > visible > prefer_tag > 先勝ち"""
        if not matches:
            return None
        # required True を優先
        req = [m for m in matches if m.get("required")]
        cand = req if req else matches
        # visible True を優先
        vis = [m for m in cand if m.get("visible")]
        cand = vis if vis else cand
        # prefer_tag（例：message なら textarea）を優先
        if prefer_tag:
            pt = [m for m in cand if (m.get("tag") == prefer_tag)]
            cand = pt if pt else cand
        return cand[0]

    def _auto_key_by_type_ac(self, f: Dict[str, Any]) -> Optional[str]:
        """type / autocomplete からキーを推定（確定強め）"""
        t = (f.get("type") or "").lower()
        if t == "email":
            return "email"
        if t == "tel":
            return "phone"
        if t == "url":
            return "website"
        ac = (f.get("autocomplete") or "").lower()
        return AUTOCOMPLETE_MAP.get(ac)

    # ========= 氏名分割の気配検出（単一氏名欄ガード用） =========
    def _detect_split_name_context(self, fields: List[Dict[str, Any]]) -> bool:
        """
        ページ（または同一行/コンテナ）に「姓/名が分かれていそうな手掛かり」があるかを判定。
        例: name02, fname/lname, first/last, given/family, ラベルに「姓/名/ふりがな」など。
        """
        try:
            for f in fields or []:
                tb = self._textbag(f)
                name_attr = (f.get("name") or "").lower()
                id_attr = (f.get("id") or "").lower()
                # 明示的な語彙（日本語/英語）
                if re.search(r"(姓|名|せい|めい|ふりがな|カナ|かな|姓.*名|名.*姓|family(-|\s*)name|given(-|\s*)name|first(-|\s*)name|last(-|\s*)name)", tb):
                    return True
                # 典型的な属性名
                if re.search(r"(name0?2|name_?first|name_?last|fname|lname|first|last|given|family)", name_attr):
                    return True
                if re.search(r"(name0?2|fname|lname|first|last|given|family)", id_attr):
                    return True
            return False
        except Exception:
            return False

    def _detect_name_field_structure(self, fields: List[Dict[str, Any]]) -> str:
        """
        氏名欄の構造を判定する
        戻り値: "single" | "split" | "unknown"
        - single: 氏名 + フリガナ (2欄)
        - split: 姓 + 名 + 姓フリガナ + 名フリガナ (4欄以上)
        - unknown: 判定不能
        """
        try:
            # 氏名関連フィールドを抽出
            name_fields = []
            for f in fields or []:
                tb = self._textbag(f)
                name_attr = (f.get("name") or "").lower()
                id_attr = (f.get("id") or "").lower()
                
                # 氏名関連の判定
                if (re.search(r"(氏名|お名前|name|姓|名|せい|めい|ふりがな|カナ|かな)", tb) or
                    re.search(r"(name|sei|mei|kana|furigana)", name_attr) or
                    re.search(r"(name|sei|mei|kana|furigana)", id_attr)):
                    name_fields.append(f)
            
            # 氏名欄の数をカウント
            name_count = len(name_fields)
            
            if name_count == 2:
                return "single"  # 氏名 + フリガナ
            elif name_count >= 4:
                return "split"   # 姓 + 名 + 姓フリガナ + 名フリガナ
            else:
                return "unknown"
        except Exception:
            return "unknown"

    def _match_cascade_for_key(self, key: str, fields: List[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        def _looks_kana(f):
            tb = self._textbag(f)
            return any(t in tb for t in ("kana","ｶﾅ","カナ","ふりがな","ﾌﾘｶﾞﾅ","セイ","メイ","せい","めい"))
        """
        判定順：
        1) type / autocomplete
        2) placeholder（完全一致）
        3) name（部分一致）
        4) id（部分一致）
        5) labelText（部分一致）
        ※ 途中でヒットしたら即決（タイブレーク経由）
        """
        # --- 氏名単一欄ガード ---
        # 分割欄の気配が無いページでは first_name / last_name を割り当てない（単一氏名欄を奪わない）
        if key in ("first_name", "last_name"):
            fields = [f for f in fields if not _looks_kana(f)]
            try:
                split_like = False
                for f in fields:
                    tb = self._textbag(f)
                    name_attr = (f.get("name") or "").lower()
                    id_attr = (f.get("id") or "").lower()
                    # ラベル/placeholder/aria/class 等に明示語があるか
                    if re.search(r"(姓|名|せい|めい|かな|カナ|ふりがな|姓.*名|family(?:-|\s*)name|given(?:-|\s*)name|first(?:-|\s*)name|last(?:-|\s*)name)", tb):
                        split_like = True
                        break
                    # name/id に典型トークンや連番があるか
                    if re.search(r"(name0?2|name_?first|name_?last|fname|lname|first|last|given|family)", name_attr):
                        split_like = True
                        break
                    if re.search(r"(name0?2|fname|lname|first|last|given|family)", id_attr):
                        split_like = True
                        break
                if not split_like:
                    return None
            except Exception:
                pass
 
        # 1) type/autocomplete
        type_hits = []
        for f in fields:
            if self._search_like(f):
                continue
            k = self._auto_key_by_type_ac(f)
            if k == key:
                type_hits.append(f)
        if type_hits:
            # email_confirm は type だけでは決まらないのでここでは本欄を優先
            if key == "email_confirm":
                # confirm らしいものを選ぶ（なければスキップ）
                confs = [f for f in type_hits if self._is_confirm_like_for_base(f, "email")]
                if confs:
                    return self._tie_break(confs)
            else:
                return self._tie_break(type_hits, prefer_tag=("textarea" if key == "message" else None))

        # 2) placeholder（完全一致）
        ph_hits = [
            f for f in fields
            if not self._search_like(f) and not self._honeypot_like(f)
            and self._match_placeholder_exact(key, (f.get("placeholder") or "").lower())
        ]
        if ph_hits:
            if key == "email_confirm":
                confs = [f for f in ph_hits if self._is_confirm_like_for_base(f, "email")]
                if confs:
                    return self._tie_break(confs)
            # placeholder経由でも、分割欄の気配が無ければ first/last のマッピングは行わない
            if key in ("first_name", "last_name"):
                split_like = False
                for f in ph_hits:
                    tb = self._textbag(f)
                    if re.search(r"(姓|名|せい|めい|family(?:-|\s*)name|given(?:-|\s*)name|first(?:-|\s*)name|last(?:-|\s*)name)", tb):
                        split_like = True
                        break
                if not split_like:
                    return None
            return self._tie_break(ph_hits, prefer_tag=("textarea" if key == "message" else None))

        # 3) name（部分一致）
        name_hits = [f for f in fields if not self._search_like(f) and not self._honeypot_like(f) and self._match_strong(key, (f.get("name") or "").lower())]
        if name_hits:
            # email_confirm 特例
            if key == "email_confirm":
                confs = [f for f in name_hits if self._is_confirm_like_for_base(f, "email")]
                if confs:
                    return self._tie_break(confs)
            return self._tie_break(name_hits, prefer_tag=("textarea" if key == "message" else None))

        # 4) id（部分一致）
        id_hits = [f for f in fields if not self._search_like(f) and not self._honeypot_like(f) and self._match_strong(key, (f.get("id") or "").lower())]
        if id_hits:
            if key == "email_confirm":
                confs = [f for f in id_hits if self._is_confirm_like_for_base(f, "email")]
                if confs:
                    return self._tie_break(confs)
            return self._tie_break(id_hits, prefer_tag=("textarea" if key == "message" else None))

        # 5) labelText（部分一致）
        lb_hits = [f for f in fields if not self._search_like(f) and not self._honeypot_like(f) and self._match_strong(key, (f.get("labelText") or "").lower())]
        if lb_hits:
            if key == "email_confirm":
                confs = [f for f in lb_hits if self._is_confirm_like_for_base(f, "email")]
                if confs:
                    return self._tie_break(confs)
            return self._tie_break(lb_hits, prefer_tag=("textarea" if key == "message" else None))

        return None

    # ========== ここまで：新規ヘルパ ==========

    async def _record_learning_signal(self, page: Page, soup: BeautifulSoup, target_key: str) -> None:
        if not getattr(self, "learn", False):
            return
        try:
            url = page.url
            bs_el: Optional[Tag] = None
            if target_key == "email":
                bs_el = soup.find("input", attrs={"type": "email"}) or soup.find(
                    "input", attrs={"name": lambda x: x and ("mail" in x.lower() or "email" in x.lower())}
                )
            elif target_key == "phone":
                bs_el = soup.find("input", attrs={"type": "tel"})
            elif target_key == "website":
                bs_el = soup.find("input", attrs={"type": "url"})
            else:
                bs_el = soup.find("input") or soup.find("textarea") or soup.find("select")

            if not bs_el:
                return

            def _attr(t: Tag, name: str) -> str:
                try:
                    v = t.get(name) or ""
                    return v if isinstance(v, str) else " ".join(v)
                except Exception:
                    return ""

            signal = {
                "target_key": target_key,
                "page_url": url,
                "name": _attr(bs_el, "name"),
                "id": _attr(bs_el, "id"),
                "class": _attr(bs_el, "class"),
                "type": _attr(bs_el, "type"),
                "placeholder": _attr(bs_el, "placeholder"),
                "aria-label": _attr(bs_el, "aria-label"),
            }
            try:
                txt = extract_label_text(bs_el, soup)
                for sw in LEARN_STOPWORDS:
                    txt = txt.replace(sw, "") if txt else txt
                txt = (txt or "").strip()
            except Exception:
                txt = ""
            signal["extracted_text"] = txt

            dedup_key = (url, target_key, signal["name"] or signal["id"], txt or "")
            if dedup_key in self._learn_seen:
                return
            self._learn_seen.add(dedup_key)

            out_path = getattr(self, "learn_out", os.path.join("lexicon", "suggestions.csv"))
            os.makedirs(os.path.dirname(out_path), exist_ok=True)
            header = [
                "target_key",
                "page_url",
                "name",
                "id",
                "class",
                "type",
                "placeholder",
                "aria-label",
                "extracted_text",
            ]
            async with self._learn_lock:
                file_exists = os.path.exists(out_path)
                async with aiofiles.open(out_path, "a", encoding="utf-8", newline="") as f:
                    if not file_exists:
                        await f.write(",".join(header) + "\n")
                    row = [signal.get(h, "").replace("\n", " ").replace(",", " ") for h in header]
                    await f.write(",".join(row) + "\n")
        except Exception as e:
            logger.debug(f"learning signal記録エラー: {e}")

    async def find_best_field_match(
        self,
        page: Page,
        field_name: str,
        exclude_selectors: Optional[set[str]] = None,
    ) -> Optional[Tuple[Any, str]]:
        """
        既存のスコア法（フォールバック用に温存）。
        """
        try:
            all_fields = []
            frames = [page] + list(page.frames)
            for frame in frames:
                try:
                    fields = await frame.query_selector_all('input, textarea, select')
                    all_fields.extend([(field, frame) for field in fields])
                except Exception:
                    continue

            norm_field = normalize(field_name)
            synonyms = CANDIDATES.get(field_name, [field_name])

            candidates = []
            import difflib

            for field, frame in all_fields:
                try:
                    attrs = {}
                    for attr in ['name', 'placeholder', 'aria-label', 'id', 'class', 'type', 'required']:
                        value = await field.get_attribute(attr)
                        if value:
                            attrs[attr] = value

                    try:
                        tag_name = (await field.evaluate('el => el.tagName.toLowerCase()')) or ''
                    except Exception:
                        tag_name = ''
                    input_type = (attrs.get('type') or '').lower()

                    score = 0
                    score_detail: List[str] = []

                    for attr in ['name', 'id', 'class']:
                        v = normalize(attrs.get(attr, ""))
                        for syn in synonyms:
                            if re.search(syn, v):
                                score += 5
                                score_detail.append(f"{attr}~{syn}:+5")

                    name_attr = attrs.get('name', '')
                    m = re.search(r'form_fields\[([^\]]+)\]', name_attr or '')
                    if m:
                        field_in_brackets = m.group(1)
                        if any(re.search(syn, field_in_brackets) for syn in synonyms):
                            score += 6
                            score_detail.append("elementor_field:+6")

                    if field_name == 'message' and tag_name == 'textarea':
                        score += 15
                        score_detail.append("textarea:+15")
                    elif field_name == 'message' and input_type == 'radio':
                        score -= 20
                        score_detail.append("radio:-20")

                    if field_name == 'subject':
                        if input_type == 'radio':
                            score += 15
                            score_detail.append("radio:+15")
                        elif tag_name == 'select':
                            score += 10
                            score_detail.append("select:+10")
                        elif tag_name == 'textarea':
                            score -= 20
                            score_detail.append("textarea:-20")

                    if field_name in ['name', 'first_name', 'last_name', 'name_last', 'name_first', 'furigana', 'kana_last', 'kana_first', 'email', 'email_confirm', 'phone', 'company', 'department', 'website']:
                        if input_type == 'radio':
                            score -= 15
                            score_detail.append("radio:-15")
                        elif tag_name == 'textarea':
                            score -= 10
                            score_detail.append("textarea:-10")
                        elif tag_name == 'select':
                            score -= 20
                            score_detail.append("select:-20")

                    label_text = await get_label_text_for_locator(frame, field)
                    if label_text:
                        for syn in synonyms:
                            if re.search(syn, label_text):
                                score += 4
                                score_detail.append(f"label~{syn}:+4")

                    for attr in ['placeholder', 'aria-label']:
                        v = normalize(attrs.get(attr, ""))
                        for syn in synonyms:
                            if re.search(syn, v):
                                score += 3
                                score_detail.append(f"{attr}~{syn}:+3")

                    t = attrs.get('type', "").lower()
                    if t == "url" and field_name == "website":
                        score += 4
                        score_detail.append("type=url:+4")
                    if t == "tel" and field_name == "phone":
                        score += 2
                        score_detail.append("type=tel:+2")
                    if t == "email" and field_name in ["email", "email_confirm"]:
                        score += 4
                        score_detail.append("type=email:+4")

                    if field_name == "website":
                        placeholder = attrs.get('placeholder', '')
                        if re.search(r'(https?://|^www\.)', placeholder.lower()):
                            score += 3
                            score_detail.append("placeholder-url:+3")

                    if attrs.get('required') is not None:
                        score += 2
                        score_detail.append("required:+2")

                    if attrs.get('type') == 'hidden':
                        score -= 10
                        score_detail.append("hidden:-10")

                    for attr in ['name', 'id', 'class', 'placeholder', 'aria-label']:
                        v = normalize(attrs.get(attr, ""))
                        if v:
                            ratio = difflib.SequenceMatcher(None, norm_field, v).ratio()
                            if ratio > 0.65:
                                score += 2
                                score_detail.append(f"{attr}-sim:+2")

                    selector = await selector_for_locator(field)
                    # ---- 企業スコープ外／personal 系／非表示は候補に入れない（強制）----
                    scope_css = getattr(self, "_corp_scope_selector", None)
                    if scope_css:
                        try:
                            inside = await self._within_scope(page, scope_css, selector)
                        except Exception:
                            inside = True
                        if not inside:
                            continue
                    try:
                        if await self._looks_personal(page, selector):
                            continue
                    except Exception:
                        pass
                    try:
                        if not await self._is_really_visible(page, selector):
                            continue
                    except Exception:
                        pass
                    candidates.append(((frame, selector), score, score_detail))

                except Exception as e:
                    logger.debug(f"フィールド処理エラー: {e}")
                    continue

            candidates.sort(key=lambda x: x[1], reverse=True)

            if self.debug:
                logger.debug(f"[フィールド探索] '{field_name}' top-3候補:")
                for i, (fr_sel, score, score_detail) in enumerate(candidates[:3]):
                    _, sel = fr_sel
                    logger.debug(f"  #{i+1}: score={score} selector={sel} detail={score_detail}")

            min_score = SPECIAL_MIN_SCORE.get(field_name, 5)
            exclude = exclude_selectors or set()
            for (best_frame, best_selector), best_score, best_detail in candidates:
                if best_selector in exclude:
                    if self.debug:
                        try:
                            logger.debug(
                                f"[フィールド探索] '{field_name}' 除外セレクタをスキップ: {best_selector}"
                            )
                        except Exception:
                            pass
                    continue
                if best_score < min_score:
                    continue

                if self.debug:
                    try:
                        locator = best_frame.locator(best_selector).first
                        await locator.evaluate("el => el.style.outline = '2px solid red'")
                    except Exception:
                        pass
                if self.debug:
                    try:
                        logger.info(
                            f"[選定] {field_name}: {best_selector} score={best_score} detail={best_detail}"
                        )
                    except Exception:
                        pass

                return (best_frame, best_selector)

            return None
        except Exception as e:
            logger.error(f"フィールド探索エラー: {e}")
            return None

    async def find_all_field_matches(self, page: Page, data: Dict[str, Any]) -> Dict[str, Tuple[Optional[Any], str]]:
        """
        旧ロジック（即決カスケード → 既存スコア法フォールバック）に戻す:
          1) extract_labels_bulk(page) で候補を一括取得
          2) 即決カスケード（type→autocomplete→placeholder→name→id→labelText）
          3) 未決定は find_best_field_match() にフォールバック
        """
        element_map: Dict[str, Tuple[Optional[Any], str]] = {}

        # 0) 会社名が必要なら、対象フィールドの出現を短時間だけ待つ（軽量・条件付き）
        need_company = ("company" in data)
        if need_company and not self.fast_mode:
            try:
                await page.wait_for_selector('input[name="company_name"], input[name*="company" i]', timeout=4000)
            except Exception:
                pass

        # 企業スコープ（未使用：旧実装互換）
        scope_selector: Optional[str] = None
        self._corp_scope_selector = scope_selector

        # 1) 一括抽出（可視のみ・personal除外）
        try:
            bulk_fields = await extract_labels_bulk(page, scope_selector=scope_selector)
        except Exception as e:
            if self.debug:
                logger.debug(f"[extract_labels_bulk] 失敗: {e}")
            bulk_fields = []
        def _visible_only(fs): return [f for f in (fs or []) if f.get("visible")]
        def _without_personal(fs):
            out=[]
            for f in fs or []:
                blob = f"{(f.get('name') or '').lower()} {(f.get('id') or '').lower()} {(f.get('class') or '').lower()}"
                if "personal_" in blob or "wpcf7-hidden" in blob:
                    continue
                out.append(f)
            return out
        bulk_fields = _without_personal(_visible_only(bulk_fields))

        # 2) 即決カスケード
        split_like = self._detect_split_name_context(bulk_fields)
        name_structure = self._detect_name_field_structure(bulk_fields)
        needed_keys = [k for k in FILLABLE_KEYS if k in data]
        if "furigana" in data:
            for k in ("kanaSei", "kanaMei"):
                if k not in needed_keys:
                    needed_keys.append(k)
        if not split_like:
            needed_keys = [k for k in needed_keys if k not in ("first_name", "last_name")]
        used_selectors: set[str] = set()
        reserved_selectors: set[str] = set()

        def _mark_reserved(selector: Optional[str]):
            if selector:
                reserved_selectors.add(selector)

        def reserve(f: Dict[str, Any], key: str):
            sel = f.get("selector")
            if not sel or sel in used_selectors:
                return False
            used_selectors.add(sel)
            _mark_reserved(sel)
            element_map[key] = (page, sel)
            return True

        # 氏名欄構造に基づいて優先順位を動的に決定
        if name_structure == "split":
            # 分割氏名の場合：first_name, last_name を優先
            priority_first = [k for k in ["email", "email_confirm", "phone", "website", "first_name", "last_name"] if k in needed_keys]
        elif name_structure == "single":
            # 単一氏名の場合：name を優先
            priority_first = [k for k in ["email", "email_confirm", "phone", "website", "name"] if k in needed_keys]
        else:
            # 不明な場合：従来通り
            priority_first = [k for k in ["email", "email_confirm", "phone", "website", "name"] if k in needed_keys]
        
        rest_keys = [k for k in needed_keys if k not in priority_first]
        cascade_order = [*priority_first, *rest_keys]

        for key in cascade_order:
            if key in element_map:
                continue
            target = self._match_cascade_for_key(
                key,
                [f for f in bulk_fields if f.get("selector") not in used_selectors]
            )
            if target:
                reserve(target, key)

        # 型ベースの救済
        def _find_by_type(fields: List[Dict[str, Any]], tval: str) -> Optional[Dict[str, Any]]:
            for f in fields:
                if f.get("selector") in used_selectors:
                    continue
                if (f.get("type") or "").lower() == tval:
                    return f
            return None
        if "website" in needed_keys and "website" not in element_map:
            t = _find_by_type(bulk_fields, "url")
            if t: reserve(t, "website")
        if "email" in needed_keys and "email" not in element_map:
            t = _find_by_type(bulk_fields, "email")
            if t: reserve(t, "email")
        if "phone" in needed_keys and "phone" not in element_map:
            t = _find_by_type(bulk_fields, "tel")
            if t: reserve(t, "phone")

        # 2.5) ヒント抽出（旧実装互換）
        hinted_keys: set[str] = set()
        try:
            for f in bulk_fields:
                if f.get("selector") in used_selectors:
                    continue
                tb = self._textbag(f)
                k_auto = self._auto_key_by_type_ac(f)
                if k_auto in needed_keys:
                    hinted_keys.add(k_auto)
                for k in needed_keys:
                    try:
                        candidates = CANDIDATES.get(k, [])
                        for pattern in candidates:
                            if re.search(pattern, tb):
                                hinted_keys.add(k); break
                    except Exception:
                        continue
        except Exception:
            hinted_keys = set(needed_keys)

        # 3) フォールバック（find_best_field_match）
        html = await page.content()
        soup = BeautifulSoup(html, "html.parser")

        # subject=corp_sub の特例
        if "subject" in data and "subject" not in element_map:
            try:
                corp_sub_el = soup.find("input", attrs={"name": "corp_sub"})
                if corp_sub_el:
                    sel = selector_for(corp_sub_el)
                    element_map["subject"] = (None, sel)
                    _mark_reserved(sel)
                    logger.info("subjectフィールド（corp_sub）を直接マッピングしました")
            except Exception as e:
                logger.debug(f"subjectフィールド（corp_sub）直接マッピングエラー: {e}")

        for key in [k for k in needed_keys if k in hinted_keys]:
            allow_kana_without_data = ("furigana" in data and key in ("kanaSei", "kanaMei"))
            if (key in data or allow_kana_without_data) and key not in element_map:
                fr_sel = await self.find_best_field_match(
                    page, key, exclude_selectors=reserved_selectors
                )
                if fr_sel:
                    _, sel = fr_sel
                    if sel in reserved_selectors:
                        fr_sel = None
                    else:
                        element_map[key] = fr_sel
                        _mark_reserved(sel)
                if not fr_sel:
                    try:
                        await self._record_learning_signal(page, soup, key)
                    except Exception:
                        pass

        # 会社名だけは軽量救済
        if need_company and "company" not in element_map:
            fr_sel = await self.find_best_field_match(
                page, "company", exclude_selectors=reserved_selectors
            )
            if fr_sel:
                _, sel = fr_sel
                if sel not in reserved_selectors:
                    element_map["company"] = fr_sel
                    _mark_reserved(sel)
        if need_company and "company" not in element_map:
            try:
                el = await page.query_selector('input[name="company_name"], input[name*="company" i]')
                if el:
                    sel = await selector_for_locator(el)
                    element_map["company"] = (page, sel)
                    logger.info("pin-rescue: company <- input[name*=company]")
            except Exception:
                pass

        # 型ベース（スコープなしの簡易版）
        if "website" not in element_map:
            try:
                loc = page.locator('input[type="url"]').first
                if await loc.count():
                    elh = await loc.element_handle()
                    if elh:
                        sel = await selector_for_locator(elh)
                        element_map["website"] = (page, sel)
            except Exception:
                pass
        if "email" in data and "email" not in element_map:
            try:
                loc = page.locator('input[type="email"]').first
                if await loc.count():
                    elh = await loc.element_handle()
                    if elh:
                        sel = await selector_for_locator(elh)
                        element_map["email"] = (page, sel)
            except Exception:
                pass
        if "phone" in data and "phone" not in element_map:
            try:
                loc = page.locator('input[type="tel"]').first
                if await loc.count():
                    elh = await loc.element_handle()
                    if elh:
                        sel = await selector_for_locator(elh)
                        element_map["phone"] = (page, sel)
            except Exception:
                pass

        # 最終安全策：単一氏名欄なら name を優先
        if not split_like and "name" in element_map:
            for k in ("first_name", "last_name"):
                if k in element_map:
                    del element_map[k]
        if "name" in element_map:
            _, name_sel = element_map["name"]
            for k in ("first_name", "last_name", "nameSei", "nameMei", "furigana"):
                if k in element_map and element_map[k][1] == name_sel:
                    del element_map[k]

        # フリガナの分割反映
        if "furigana" in data:
            last_kana, first_kana = split_name(data["furigana"])
            kana_sei_mapped = "kanaSei" in element_map
            kana_mei_mapped = "kanaMei" in element_map
            if kana_sei_mapped:
                data["kanaSei"] = last_kana
            if kana_mei_mapped:
                data["kanaMei"] = first_kana
            if kana_sei_mapped and kana_mei_mapped:
                element_map.pop("furigana", None)

        return element_map

    # =========================
    # 分割型・電話欄の自動分配
    # =========================
    async def _fill_phone_group(self, base, locator, phone_str: str) -> bool:
        """
        電話番号が複数 input に分割されている場合（例: tel[data][0..2] / tel1,tel2,tel3 など）に
        コンテナ内の同一グループを検出し、値を各欄に自動分配する。

        検知条件（実戦向け）:
          - 同一コンテナ内で name / class のトークンに {tel, phone, denwa, 電話} が 3 回以上
          - 補助シグナルのいずれか ≥ 1:
              * 兄弟に '-' テキスト
              * hidden に name*="tel" かつ name*="separator"
              * 直近見出し(th/label等)に「電話番号」/「TEL」
              * type="tel" or maxlength<=4 が複数
        """
        try:
            group_info = await locator.evaluate(
                """
                (el) => {
                  const container =
                    el.closest('.mwform-tel-field,.tel_wrap') ||
                    el.closest('td,div,form') ||
                    el.parentElement;
                  if (!container) return null;

                  const tokenize = (s) => (s||"").toLowerCase().split(/[^a-z0-9一-龥ぁ-んァ-ンー]+/).filter(Boolean);
                  const hasTelToken = (s) => {
                    const toks = new Set(tokenize(s));
                    // tel/phone/denwa/電話 をトークン単位で判定（hotel対策）
                    return toks.has("tel") || toks.has("phone") || toks.has("denwa") || toks.has("電話");
                  };

                  // 候補抽出
                  const allInputs = Array.from(container.querySelectorAll('input[type="tel"], input[type="text"]'));
                  const cands = allInputs.filter(i => {
                    const n = i.getAttribute('name') || '';
                    const c = i.getAttribute('class') || '';
                    return hasTelToken(n) || hasTelToken(c);
                  });

                  // 3回ルール（tel系トークンが3つ以上）
                  if (cands.length < 3) return null;

                  // 補助シグナル
                  const textContent = container.textContent || '';
                  const hasHyphen = /-/.test(textContent);
                  const sepHidden = !!container.querySelector('input[type="hidden"][name*="tel"][name*="separator"]');
                  const th = container.closest('tr')?.querySelector('th')?.innerText || '';
                  const labelHit = /(電話|TEL)/i.test(th);
                  const smallMaxLenCount = cands.filter(i => {
                    const ml = i.getAttribute('maxlength');
                    return ml && /^\d+$/.test(ml) && parseInt(ml,10) <= 4;
                  }).length;
                  const typeTelCount = cands.filter(i => (i.getAttribute('type')||'').toLowerCase() === 'tel').length;

                  const auxScore = (hasHyphen?1:0) + (sepHidden?1:0) + (labelHit?1:0) + ((smallMaxLenCount>=2)?1:0) + ((typeTelCount>=2)?1:0);
                  if (auxScore < 1) return null; // 補助シグナル最低1

                  // 並び順（name末尾の [idx] or 数字で昇順、無ければ DOM順のまま）
                  const withIdx = cands.map(i => {
                    const n = i.getAttribute('name') || '';
                    const m = n.match(/\[(\d+)\](?!.*\[)/) || n.match(/(\d+)$/);
                    return {
                      name: n,
                      idx: m ? parseInt(m[1],10) : 1e9,
                      maxlen: (() => {
                        const ml = i.getAttribute('maxlength');
                        return (ml && /^\d+$/.test(ml)) ? parseInt(ml,10) : null;
                      })()
                    };
                  }).sort((a,b)=>a.idx-b.idx);

                  return {
                    names: withIdx.map(x=>x.name).filter(Boolean),
                    maxlens: withIdx.map(x=>x.maxlen)
                  };
                }
                """
            )

            if not group_info or not group_info.get("names"):
                return False

            # 入力値を数字のみへ正規化
            digits = re.sub(r"\D", "", str(phone_str or ""))
            if not digits:
                return False

            names: List[str] = list(group_info["names"])
            maxlens: List[Optional[int]] = list(group_info["maxlens"])

            # maxlen が全て未指定 → 10/11桁の定番 or 均等割り
            if all(v is None for v in maxlens):
                if len(digits) == 10:
                    maxlens = [3,3,4][:len(names)]
                elif len(digits) == 11:
                    maxlens = [3,4,4][:len(names)]
                else:
                    q, r = divmod(len(digits), len(names))
                    maxlens = [q + (1 if i < r else 0) for i in range(len(names))]

            # 左から順に割り当て
            pos = 0
            for i, n in enumerate(names):
                ln = maxlens[i] or max(1, (len(digits) - pos) // max(1, (len(names) - i)) )
                part = digits[pos:pos+ln]
                await base.locator(f'input[name="{n}"]').first.fill(part)
                pos += len(part)

            return True
        except Exception as _:
            return False

    async def fill_form(self, page: Page, data: Dict[str, Any]) -> tuple[bool, Any, List[str]]:
        """フォーム入力（CSSセレクタ使用）"""
        try:
            element_map = await self.find_all_field_matches(page, data)
            for k, v in list(element_map.items()):
                if isinstance(v, str):
                    element_map[k] = (None, v)

            # マッピングの可視化（--emit-json 時）：key と selector をJSONで1行出力
            if getattr(self, "emit_json", False):
                try:
                    mapping = []
                    for key, val in element_map.items():
                        frame, selector = val if isinstance(val, tuple) else (None, val)
                        mapping.append({
                            "key": key,
                            "selector": selector,
                            # method や confidence を持っていない実装のため省略（拡張余地）
                        })
                    print(json.dumps({
                        "event": "mapping",
                        "mapping": mapping,
                    }), flush=True)
                except Exception:
                    # 可視化が失敗しても本処理は続行
                    pass

            active_form_handle = None

            # 氏名の分割（既存）
            if "name" in data:
                last_name, first_name = split_name(data["name"])
                if "last_name" in data:
                    data["last_name"] = last_name
                if "first_name" in data:
                    data["first_name"] = first_name
                # --- ここから堅牢化 ---
                # 両方の別セレクタが揃っているときだけ「分割氏名」とみなす。
                fn = element_map.get("first_name")
                ln = element_map.get("last_name")
                nm = element_map.get("name")
                fn_sel = fn[1] if fn else None
                ln_sel = ln[1] if ln else None
                nm_sel = nm[1] if nm else None

                # 旧ロジック：両方そろった時だけ分割氏名。片側/不明なら name に格下げ。
                split_detected = bool(fn_sel and ln_sel and fn_sel != ln_sel)
                if split_detected:
                    if "name" in element_map:
                        del element_map["name"]
                    logger.info("姓/名の2フィールドを検出：フルネーム欄をスキップ")
                else:
                    if not nm_sel:
                        if fn_sel:
                            element_map["name"] = element_map["first_name"]; nm_sel = fn_sel
                        elif ln_sel:
                            element_map["name"] = element_map["last_name"];  nm_sel = ln_sel
                    element_map.pop("first_name", None)
                    element_map.pop("last_name", None)
                # --- ここまで堅牢化 ---

            if "furigana" in data:
                last_kana, first_kana = split_name(data["furigana"])
                if "last_name" in data and "last_name" not in element_map:
                    data["last_name"] = last_kana
                if "first_name" in data and "first_name" not in element_map:
                    data["first_name"] = first_kana

            # 追記：確認欄（email_confirm）へ本欄の値をコピー（前倒し）
            if ("email" in element_map) and ("email_confirm" in element_map) and ("email" in data):
                data["email_confirm"] = data.get("email_confirm") or data["email"]

            keys_primary = [k for k in PRIORITY_KEYS if k in FILLABLE_KEYS]
            keys_rest = [k for k in FILLABLE_KEYS if k not in keys_primary]
            for key in [*keys_primary, *keys_rest]:
                if key in data and key in element_map:
                    fr, selector = element_map[key]
                    value = data[key]
                    try:
                        base = fr or page
                        locator = base.locator(selector).first
                        # --- デモ可視化（入力前） ---
                        if self.show_browser and self.demo_ms:
                            try:
                                prev = str(value)
                                if len(prev) > 24: prev = prev[:24] + "…"
                                await self._demo_flash(page, locator, key, prev)
                                await page.wait_for_timeout(self.demo_ms)
                            except Exception:
                                pass
                        # --- 入力直前の最終ガード：スコープ外／personal系はスキップ ---
                        scope_css = getattr(self, "_corp_scope_selector", None)
                        if scope_css:
                            try:
                                if not await self._within_scope(page, scope_css, selector):
                                    logger.warning(f"[SCOPED-BLOCK] out-of-scope key='{key}' selector={selector}")
                                    continue
                            except Exception:
                                pass
                        try:
                            if await self._looks_personal(page, selector):
                                logger.warning(f"[SCOPED-BLOCK] personal key='{key}' selector={selector}")
                                continue
                        except Exception:
                            pass
                        if not active_form_handle:
                            try:
                                _eh = await locator.element_handle()
                                if _eh:
                                    _tmp = await _eh.evaluate_handle(
                                        """el => el.closest('form')
                                            || el.closest('[role="form"]')
                                            || el.closest('.wpcf7-form')
                                            || el.closest('[class*="form"]')
                                            || document"""
                                    )
                                    _form_el = _tmp.as_element()
                                    active_form_handle = _form_el if _form_el else None
                            except Exception:
                                pass

                        tag_name = await locator.evaluate('el => el.tagName.toLowerCase()')
                        input_type = await locator.get_attribute('type')

                        if logger.isEnabledFor(logging.DEBUG) or self.debug:
                            logger.debug(f"[入力] '{key}' → selector={selector} tag={tag_name} type={input_type} value={value}")

                        if tag_name == 'select':
                            if key == 'subject':
                                try:
                                    await locator.select_option(value=str(value))
                                except Exception as e:
                                    logger.info(f"通常のselect_option失敗: {e}")
                                    try:
                                        await locator.evaluate(f"el => {{ el.value = '{value}'; el.dispatchEvent(new Event('change', {{bubbles: true}})); }}")
                                    except Exception:
                                        pass
                            else:
                                await locator.select_option(value=str(value))
                        elif tag_name == 'textarea':
                            # textareaは既定でお問い合わせ内容（既存方針：あなた側で解決済み）
                            inquiry_content = data.get('inquiry_template', "お問い合わせありがとうございます。\n\n製品・サービスについて詳しく知りたいです。\n\n具体的には以下の点について教えていただけますでしょうか：\n・料金体系\n・導入事例\n・サポート体制\n\nよろしくお願いいたします。")
                            try:
                                ng_model = await locator.get_attribute('data-ng-model')
                                if ng_model:
                                    await locator.evaluate(f"""el => {{
                                        el.value = `{inquiry_content}`;
                                        el.dispatchEvent(new Event('input', {{bubbles: true}}));
                                        el.dispatchEvent(new Event('change', {{bubbles: true}}));
                                        if (window.angular && window.angular.element) {{
                                            const scope = window.angular.element(el).scope();
                                            if (scope) {{ scope.$apply(); }}
                                        }}
                                    }}""")
                                    await page.wait_for_timeout(500 if not self.fast_mode else 50)
                                else:
                                    await locator.fill(inquiry_content)
                            except Exception:
                                await locator.fill(inquiry_content)
                        elif input_type == 'checkbox':
                            if value:
                                await locator.check()
                        elif input_type == 'radio':
                            # --- Radio selection: scope to the same <form>, visible only, label-first, then verify ---
                            # 1) group name
                            group_name = None
                            try:
                                eh = await locator.element_handle()
                                if eh:
                                    group_name = await eh.get_attribute('name')
                            except Exception:
                                group_name = None

                            # 2) scope to the form that contains this field (Locator, not ElementHandle)
                            try:
                                form_scope = base.locator("form").filter(has=locator).first
                                scope = form_scope if await form_scope.count() > 0 else base
                            except Exception:
                                scope = base

                            # 3) collect visible radios in the same form
                            radios = []
                            if group_name:
                                grp = scope.locator(f'input[type="radio"][name="{group_name}"]:visible:not([disabled])')
                                try:
                                    cnt = await grp.count()
                                except Exception:
                                    cnt = 0
                                for i in range(cnt):
                                    radios.append(grp.nth(i))
                            if not radios:
                                radios.append(locator)  # fallback

                            # 4) pick target (desired similarity -> else 2nd -> else 1st)
                            desired = (str(value) if value is not None else "").strip().lower()
                            import difflib
                            prefer_other = 'その他' in desired
                            best_idx, best_score = -1, -1.0
                            for i, r in enumerate(radios):
                                try:
                                    v = (await r.get_attribute('value') or '').strip()
                                    txt = await r.evaluate("""n => {
                                        const lab = n.closest('label');
                                        if (lab) return lab.innerText.trim();
                                        const id = n.getAttribute('id');
                                        if (id){
                                            const l = document.querySelector('label[for="'+id+'"]');
                                            if (l) return l.innerText.trim();
                                        }
                                        return (n.getAttribute('aria-label')||'').trim();
                                    }""")
                                    blob = f"{v} {txt}".strip().lower()
                                    sim = difflib.SequenceMatcher(None, desired, blob).ratio() if desired else 0.0
                                    if prefer_other and ('その他' in blob):
                                        sim += 0.2
                                    if sim > best_score:
                                        best_score, best_idx = sim, i
                                except Exception:
                                    continue
                            if 0 <= best_idx < len(radios):
                                final = radios[best_idx]
                            elif len(radios) > 1:
                                final = radios[1]  # "上から2番目"優先
                            else:
                                final = radios[0]

                            # 5) click label -> input -> direct events, then verify
                            async def _select_radio(r):
                                rid = await r.get_attribute('id')
                                lab = None
                                if rid:
                                    lab = scope.locator(f'label[for="{rid}"]').first
                                    if await lab.count() == 0:
                                        lab = None
                                if lab:
                                    try:
                                        await lab.click(force=True)
                                        return
                                    except Exception:
                                        pass
                                # try input
                                try:
                                    await r.check(force=True)
                                    return
                                except Exception:
                                    pass
                                # last resort: set + dispatch
                                await r.evaluate("""e => {
                                    e.checked = true;
                                    e.dispatchEvent(new Event('input', {bubbles:true}));
                                    e.dispatchEvent(new Event('change', {bubbles:true}));
                                }""")

                            await _select_radio(final)
                            ok = False
                            try:
                                ok = await final.is_checked()
                            except Exception:
                                ok = False
                            if not ok and len(radios) > 0:
                                fb = radios[1] if len(radios) > 1 and radios[1] != final else radios[0]
                                await _select_radio(fb)
                            # --- end radio selection ---
                        else:
                            # ★ phone 特例：分割型を検知できればグループに分配して通常処理はスキップ
                            if key == 'phone':
                                try:
                                    handled = await self._fill_phone_group(base, locator, value)
                                except Exception:
                                    handled = False
                                if handled:
                                    logger.info("電話番号を分割欄に自動分配しました")
                                    continue

                            if key == 'website':
                                val = value or data.get("company_url")
                                import re as _re
                                if val and not _re.match(r"^https?://", val, _re.I):
                                    val = "https://" + val
                                await locator.fill(val)
                            else:
                                await locator.fill(str(value))

                        logger.info(f"フィールド '{key}' に '{value}' を入力")
                        # --- デモ可視化（入力後OKマーク） ---
                        if self.show_browser and self.demo_ms:
                            try:
                                await self._demo_mark_ok(locator)
                                await page.wait_for_timeout(min(300, max(120, self.demo_ms//2)))
                            except Exception: pass

                    except Exception as e:
                        logger.error(f"フィールド入力エラー {key}: {e}")
                        continue

            # === 追加: どんな textarea でも埋める（未入力・可視・有効なもの） ===
            try:
                # --- 修正：救済は企業シグネチャかつスコープ内の textarea に限定 ---
                base = page
                scope_css = getattr(self, "_corp_scope_selector", None)
                if scope_css:
                    try:
                        base = page.locator(scope_css)
                    except Exception:
                        base = page
                # 企業らしさを持つtextareaを優先
                tloc = base.locator('textarea[name*="company"], textarea[id*="company"], textarea[name="company_your_message"]')
                cnt = await tloc.count()
                if cnt:
                    ta = tloc.first
                    try:
                        cur = await ta.input_value()
                    except Exception:
                        cur = await ta.evaluate("el => el.value || ''")
                    if not (cur or "").strip():
                        inquiry_content = (
                            data.get('inquiry_template')
                            or data.get('message')
                            or "お問い合わせありがとうございます。内容を確認の上、ご連絡いたします。"
                        )
                        try:
                            await ta.fill(inquiry_content)
                        except Exception:
                            await ta.evaluate(
                                """(el, v) => { el.value = v;
                                    el.dispatchEvent(new Event('input', {bubbles:true}));
                                    el.dispatchEvent(new Event('change', {bubbles:true})); }""",
                                inquiry_content,
                            )
                        logger.info("textarea を自動入力（無名/救済）")
                else:
                    # NEW: 汎用の可視textareaを1つだけ救済入力
                    inquiry_content = (
                        data.get('inquiry_template')
                        or data.get('message')
                        or "お問い合わせありがとうございます。内容を確認の上、ご連絡いたします。"
                    )
                    try:
                        await fallback_fill_textarea(page, inquiry_content, dry_run=self.dry_run, scope_selector=scope_css)
                        logger.info("textarea を自動入力（汎用救済）")
                    except Exception:
                        logger.warning("textarea 救済に失敗（汎用）")
            except Exception:
                pass

            unmapped = [k for k in FILLABLE_KEYS if k in data and k not in element_map]
            if unmapped:
                logger.warning("unmapped: %s", ",".join(unmapped))
            return True, active_form_handle, unmapped
        except Exception as e:
            logger.error(f"フォーム入力エラー: {e}")
            return False, None, []

    async def detect_captcha(self, page: Page) -> Tuple[Optional[str], Dict[str, Any]]:
        """CAPTCHA検出（reCAPTCHA/hCaptchaのsitekey抽出含む）"""
        captcha_info: Dict[str, Any] = {}
        # 1) reCAPTCHA（class/属性ベース）
        try:
            recaptcha_candidates = await page.query_selector_all(
                '.g-recaptcha, .grecaptcha-badge, [class*="grecaptcha" i], [data-sitekey].g-recaptcha, [data-sitekey][class*="grecaptcha" i]'
            )
        except Exception:
            recaptcha_candidates = []
        for element in recaptcha_candidates:
            try:
                klass = ((await element.get_attribute('class')) or '').lower()
                if 'hcaptcha' in klass or 'h-captcha' in klass:
                    continue
                site_key = await element.evaluate(
                    """
                    n => (
                        n.getAttribute('data-sitekey')
                        || (n.closest('[data-sitekey]') && n.closest('[data-sitekey]').getAttribute('data-sitekey'))
                        || (n.querySelector('[data-sitekey]') && n.querySelector('[data-sitekey]').getAttribute('data-sitekey'))
                        || ''
                    )
                    """
                )
                if site_key:
                    captcha_info['type'] = 'recaptcha'
                    captcha_info['site_key'] = site_key
                    captcha_info['element'] = element
                    return 'recaptcha', captcha_info
            except Exception:
                continue
        # 2) hCaptcha
        try:
            hcaptcha_candidates = await page.query_selector_all(
                '.h-captcha, [class*="hcaptcha" i]'
            )
        except Exception:
            hcaptcha_candidates = []
        for element in hcaptcha_candidates:
            try:
                klass = ((await element.get_attribute('class')) or '').lower()
                if 'hcaptcha' in klass or 'h-captcha' in klass:
                    site_key = await element.evaluate(
                        """
                        n => (
                            n.getAttribute('data-sitekey')
                            || (n.closest('[data-sitekey]') && n.closest('[data-sitekey]').getAttribute('data-sitekey'))
                            || (n.querySelector('[data-sitekey]') && n.querySelector('[data-sitekey]').getAttribute('data-sitekey'))
                            || ''
                        )
                        """
                    )
                    if site_key:
                        captcha_info['type'] = 'hcaptcha'
                        captcha_info['site_key'] = site_key
                        captcha_info['element'] = element
                        return 'hcaptcha', captcha_info
            except Exception:
                continue
        return None, captcha_info

    async def handle_captcha(self, page: Page, captcha_type: str, captcha_info: Dict[str, Any]) -> bool:
        """CAPTCHA解決→トークン適用"""
        # 遅延初期化
        if self.captcha_api != "none" and self.captcha_handler is None:
            try:
                self.captcha_handler = CaptchaHandler(self.captcha_api)
            except ValueError:
                logger.warning("CAPTCHAキー未設定のためスキップ")
                return False
        if not self.captcha_handler:
            return False
        try:
            site_key = captcha_info.get('site_key', '')
            page_url = page.url
            if captcha_type == 'recaptcha':
                solution = await self.captcha_handler.solve_recaptcha_v2(site_key, page_url)
            elif captcha_type == 'hcaptcha':
                solution = await self.captcha_handler.solve_hcaptcha(site_key, page_url)
            else:
                logger.warning(f"未対応のCAPTCHAタイプ: {captcha_type}")
                return False
            if solution:
                if captcha_type == 'recaptcha':
                    await page.evaluate(
                        """
                      token => {
                        const t = document.createElement('textarea');
                        t.name = 'g-recaptcha-response';
                        t.id = 'g-recaptcha-response';
                        t.style.display = 'none';
                        t.value = token;
                        (document.querySelector('form') || document.body).appendChild(t);
                      }
                    """, solution,
                    )
                elif captcha_type == 'hcaptcha':
                    await page.evaluate(
                        """
                        ({ siteKey, token }) => {
                            const n = document.querySelector(`[data-sitekey="${siteKey}"]`) || document.body;
                            const t = document.createElement('textarea');
                            t.name = 'h-captcha-response';
                            t.value = token;
                            t.style.display = 'none';
                            n.appendChild(t);
                        }
                        """,
                        {"siteKey": site_key, "token": solution}
                    )
                logger.info(f"{captcha_type} 解決完了")
                return True
            else:
                logger.error(f"{captcha_type} 解決失敗")
                return False
        except Exception as e:
            logger.error(f"CAPTCHA処理エラー: {e}")
            return False

    async def check_success(self, page: Page, original_url: str) -> Tuple[bool, str]:
        """送信成功判定（URL/POST/文言/フォームリセットを総合判定）"""
        try:
            current_url = page.url
            if current_url != original_url:
                if any(k in current_url.lower() for k in ['/thanks', '/complete', '/success', '/thank', 'done', 'sent']):
                    return True, "url_change"

            posted = False
            try:
                await page.wait_for_function(
                    "window.location.href !== args[0]",
                    arg=original_url,
                    timeout=1500,
                )
                posted = True
            except Exception:
                posted = False

            if not posted:
                def _any_post(resp):
                    try:
                        return resp.request.method in ('POST','PUT')
                    except Exception:
                        return False
                try:
                    await page.wait_for_response(_any_post, timeout=3000)
                    posted = True
                except Exception:
                    posted = False

            phrases = [
                'お問い合わせありがとうございました', '送信が完了', '送信完了', '送信されました',
                'お問い合わせを受け付けました', '送信ありがとうございます', '受け付けました',
                '受付完了', 'ありがとうございました'
            ]
            for ph in phrases:
                try:
                    loc = page.get_by_text(ph, exact=False).first
                    if await loc.is_visible():
                        note = f"visible_phrase:{ph}"
                        if posted:
                            note += "|post_detected"
                        return True, note
                except Exception:
                    pass

            try:
                keywords = ['contact', 'inquiry', 'form', 'wpcf7', 'submit', 'send', 'mail']
                def _form_post(resp):
                    try:
                        if resp.request.method not in ('POST','PUT'):
                            return False
                        return any(k in resp.url.lower() for k in keywords)
                    except Exception:
                        return False

                response = await page.wait_for_response(_form_post, timeout=2000)
                if response and response.ok:
                    ctype = (response.headers.get('content-type') or '').lower()
                    if 'application/json' in ctype:
                        try:
                            data = await response.json()
                            if isinstance(data, dict) and (data.get('success') or data.get('status') in ('success', 'ok', 'sent', True)):
                                return True, f"post_json_success:{response.url}"
                            if any(k in json.dumps(data).lower() for k in ['ok', 'sent', 'thank', 'ありがとうございます']):
                                return True, f"post_json_heuristic:{response.url}"
                        except Exception:
                            pass
                    else:
                        try:
                            txt = (await response.text()).lower()
                            if any(k in txt for k in ['ありがとうございます', '送信', '完了']):
                                return True, f"post_text_success:{response.url}"
                        except Exception:
                            pass
            except Exception:
                pass

            try:
                cleared = await page.evaluate("""() => {
                    const f = document.querySelector('form');
                    if (!f) return false;
                    const fields = Array.from(f.querySelectorAll('input[type=text], input[type=email], textarea'));
                    if (fields.length === 0) return false;
                    const emptyRate = fields.filter(x => !x.value || x.value.trim() === '').length / fields.length;
                    return emptyRate >= 0.7;
                }""")
                if cleared:
                    return True, "fields_cleared"
            except Exception:
                pass

            note = "no_success_indicator"
            if not posted:
                note += "|no_post_detected"
            return False, note

        except Exception as e:
            logger.error(f"成功判定エラー: {e}")
            return False, f"error:{e}"

    async def process_form(self, task: FormTask) -> FormResult:
        """フォーム処理"""
        async with self.global_limiter, self._domain_limiter(task.form_url):
            try:
                async with async_playwright() as p:
                    browser = await p.chromium.launch(
                        headless=not self.show_browser,
                        args=[
                            '--no-sandbox',
                            '--disable-dev-shm-usage',
                            '--disable-gpu',
                            '--disable-web-security',
                            '--disable-features=VizDisplayCompositor'
                        ]
                    )

                    # Service Worker無効化とセキュリティ制限バイパスで高速化
                    # ブラウザウィンドウサイズ設定（より見やすいサイズに調整）
                    if self.show_browser:
                        # 環境変数でサイズ指定可能
                        import os
                        custom_width = os.getenv('BROWSER_WIDTH')
                        custom_height = os.getenv('BROWSER_HEIGHT')
                        
                        if custom_width and custom_height:
                            viewport_width = int(custom_width)
                            viewport_height = int(custom_height)
                        else:
                            # デフォルトサイズ（ノートPCに適したサイズ）
                            viewport_width = 1366
                            viewport_height = 768
                    else:
                        # headlessモードでは大きなサイズ
                        viewport_width = 1920
                        viewport_height = 1080
                    
                    context = await browser.new_context(
                        viewport={'width': viewport_width, 'height': viewport_height},
                        user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                        service_workers="block",  # Service Workerを無効化して高速化
                        bypass_csp=True,  # Content Security Policyをバイパス
                        ignore_https_errors=True  # HTTPS証明書エラーを無視
                    )
                    # 高速化モードではタイムアウトを短縮
                    timeout_ms = (self.timeout // 2) * 1000 if self.fast_mode else self.timeout * 1000
                    context.set_default_timeout(timeout_ms)

                    async def _smart_block(route):
                        r = route.request
                        url = r.url
                        rtype = r.resource_type
                        
                        # フォーム機能に必要なドメインは必ず許可
                        if is_form_helper(url):
                            await route.continue_()
                            return
                        
                        # 広告・解析系ドメインはブロック
                        if is_ad_or_analytics(url):
                            await route.abort()
                            return
                        
                        # 既存のブロック条件（image, font, media）
                        if rtype in ("image", "font", "media"):
                            await route.abort()
                            return
                        
                        # その他は許可
                        await route.continue_()
                    await context.route("**/*", _smart_block)

                    page = await context.new_page()
                    
                    # ブラウザウィンドウの位置を調整（画面中央に配置）
                    if self.show_browser:
                        await page.evaluate("""
                            window.moveTo(
                                Math.max(0, (screen.width - window.outerWidth) / 2),
                                Math.max(0, (screen.height - window.outerHeight) / 2)
                            );
                        """)

                    # ページ遷移を高速化：DOM準備完了時点で処理継続（CSS/JS読み込み待機なし）
                    await page.goto(task.form_url, timeout=12000, wait_until="domcontentloaded")

                    # 待機処理
                    try:
                        await page.wait_for_selector("form", state="attached", timeout=timeout_ms)
                    except Exception:
                        pass

                    if logger.isEnabledFor(logging.DEBUG) or self.debug:
                        logger.debug(f"[ページロード] {task.form_url}")
                        content = await page.content()
                        logger.debug(f"[ページHTML先頭] {content[:500]}")

                    fill_result, active_form_handle, unmapped = await self.fill_form(page, task.data)
                    if not fill_result:
                        await browser.close()
                        return FormResult(
                            form_url=task.form_url,
                            status="ERROR",
                            note="フォーム入力失敗",
                            timestamp=datetime.now().isoformat(),
                            unmapped_fields=','.join(unmapped) if unmapped else ''
                        )

                    # 問い合わせ種別などのチェックボックス（同意以外）を最低1つON
                    try:
                        await try_check_any_non_consent_checkbox(page, logger=logger, debug=self.debug)
                    except Exception:
                        pass
                    # 同意系チェックボックス/ラジオもON（送信に必須な場合が多い）
                    try:
                        await ensure_acceptance(page, logger=logger, debug=self.debug)
                    except Exception:
                        pass
                    # 必須ラジオグループが未選択なら安全側で確定
                    try:
                        await ensure_required_radio_groups(page, logger=logger)
                    except Exception:
                        pass

                    try:
                        await choose_second_option_in_form(page, active_form_handle, logger=logger)
                    except Exception:
                        pass

                    # バリデーションエラーチェック・リトライ（無効化）
                    # try:
                    #     errors = await page.query_selector_all('.error, .validation-error, [aria-invalid=true]')
                    #     if errors:
                    #         logger.warning("バリデーションエラー検出、再マッピング実行")
                    #         fill_result, active_form_handle, unmapped = await self.fill_form(page, task.data)
                    #         try:
                    #             await choose_second_option_in_form(page, active_form_handle, logger=logger)
                    #         except Exception:
                    #             pass
                    # except Exception:
                    #     pass

                    # CAPTCHA検出・処理
                    captcha_type, captcha_info = await self.detect_captcha(page)
                    if captcha_type:
                        logger.info(f"CAPTCHA検出: {captcha_type}")
                        if not await self.handle_captcha(page, captcha_type, captcha_info):
                            await browser.close()
                            return FormResult(
                                form_url=task.form_url,
                                status="CAPTCHA_FAIL",
                                note=f"{captcha_type}解決失敗",
                                timestamp=datetime.now().isoformat()
                            )

                    if self.dry_run:
                        await browser.close()
                        return FormResult(
                            form_url=task.form_url,
                            status="DRY_RUN",
                            note="送信スキップ（dry-run）",
                            timestamp=datetime.now().isoformat()
                        )


                    # 送信ボタン検索・クリック（強化版）
                    self._clicked_submit_selector = None
                    submitted = False
                    # 入力した要素が属するフォーム/コンテナ配下を優先的に探索
                    try:
                        base = (active_form_handle.locator(":scope") if active_form_handle else page)
                    except Exception:
                        base = page

                    # 1) roleベース（最優先）- ナビゲーションリンクを除外
                    role_patterns = [
                        r"送信(する)?", r"送る", r"確認(する)?", r"同意して送信", r"申し込", r"お問い合わせ(する)?",
                        r"submit", r"send", r"confirm", r"next"
                    ]
                    if not submitted:
                        for role in ["button", "link"]:
                            for pat in role_patterns:
                                try:
                                    loc = base.get_by_role(role, name=re.compile(pat, re.I))
                                    cnt = await loc.count()
                                    if logger.isEnabledFor(logging.DEBUG) or self.debug:
                                        logger.debug(f"[送信ボタン探索:role] role={role} pat={pat} count={cnt}")
                                    if cnt > 0:
                                        # ナビゲーションリンクを除外（href属性を持つ要素をスキップ）
                                        valid_buttons = []
                                        for i in range(cnt):
                                            btn = loc.nth(i)
                                            try:
                                                href = await btn.get_attribute("href")
                                                if href and (href.startswith("/") or href.startswith("http")):
                                                    # ナビゲーションリンクを除外
                                                    continue
                                                # 送信ボタンかどうか確認（type="submit"または送信関連のクラス）
                                                btn_type = await btn.get_attribute("type")
                                                btn_class = await btn.get_attribute("class")
                                                if btn_type == "submit" or (btn_class and any(x in btn_class.lower() for x in ["submit", "send", "送信"])):
                                                    valid_buttons.append(btn)
                                                elif not href:  # hrefがない場合は追加
                                                    valid_buttons.append(btn)
                                            except Exception:
                                                valid_buttons.append(btn)

                                        if valid_buttons:
                                            btn = valid_buttons[0]
                                            try:
                                                await btn.scroll_into_view_if_needed(timeout=2000)
                                            except Exception:
                                                pass
                                            try:
                                                if self.no_submit:
                                                    logger.info("テストモード: 送信ボタンを押さずにスキップ")
                                                    submitted = True
                                                    self._clicked_submit_selector = f"role={role},name~/{pat}/i (SKIPPED)"
                                                else:
                                                    await btn.click(timeout=3000)
                                                    submitted = True
                                                    self._clicked_submit_selector = f"role={role},name~/{pat}/i"
                                                # クリック直後に待機時間を延長（送信処理の完了を待つ）
                                                await page.wait_for_timeout(2000)

                                                # デバッグ：クリック後の状態確認
                                                if logger.isEnabledFor(logging.DEBUG) or self.debug:
                                                    try:
                                                        # エラーメッセージの確認
                                                        errors = await page.query_selector_all('.error, .validation-error, [aria-invalid=true], .alert, .message, .notice, .warning')
                                                        if errors:
                                                            logger.debug(f"[送信後] エラーメッセージ数: {len(errors)}")
                                                            for i, err in enumerate(errors[:5]):
                                                                try:
                                                                    err_text = await err.inner_text()
                                                                    err_class = await err.get_attribute('class')
                                                                    logger.debug(f"[送信後] エラー#{i+1}: class={err_class}, text={err_text[:100]}")
                                                                except Exception:
                                                                    pass

                                                        # フォームの状態確認
                                                        form_state = await page.evaluate("""() => {
                                                            const form = document.querySelector('form');
                                                            if (!form) return 'no_form';
                                                            const inputs = form.querySelectorAll('input, textarea, select');
                                                            const required = Array.from(inputs).filter(x => x.required && !x.value.trim());
                                                            return {
                                                                total_inputs: inputs.length,
                                                                required_empty: required.length,
                                                                required_names: required.map(x => x.name || x.id || 'unnamed')
                                                            };
                                                        }""")
                                                        logger.debug(f"[送信後] フォーム状態: {form_state}")

                                                        # ページのURL変化確認
                                                        current_url = page.url
                                                        logger.debug(f"[送信後] 現在のURL: {current_url}")

                                                        # 成功メッセージの確認
                                                        success_selectors = [
                                                            '.success', '.message-success', '.alert-success',
                                                            '[class*="success"]', '[class*="complete"]', '[class*="thank"]'
                                                        ]
                                                        for sel in success_selectors:
                                                            try:
                                                                success_el = await page.query_selector(sel)
                                                                if success_el:
                                                                    success_text = await success_el.inner_text()
                                                                    logger.debug(f"[送信後] 成功メッセージ({sel}): {success_text[:100]}")
                                                            except Exception:
                                                                pass

                                                        # JavaScriptコンソールエラーの確認
                                                        console_errors = await page.evaluate("""() => {
                                                            if (window.console && window.console.errors) {
                                                                return window.console.errors.slice(-3);
                                                            }
                                                            return [];
                                                        }""")
                                                        if console_errors:
                                                            logger.debug(f"[送信後] コンソールエラー: {console_errors}")

                                                    except Exception as e:
                                                        logger.debug(f"[送信後] 状態確認エラー: {e}")
                                                break
                                            except Exception as e:
                                                if logger.isEnabledFor(logging.DEBUG) or self.debug:
                                                    logger.debug(f"[送信ボタンクリック:role] role={role} pat={pat} error={e}")
                                except Exception as e:
                                    if logger.isEnabledFor(logging.DEBUG) or self.debug:
                                        logger.debug(f"[送信ボタン探索:role] role={role} pat={pat} error={e}")
                            if submitted:
                                break

                    # 2) CSSセレクタでのテキスト照合（:has-text など）- ネストされたテキスト要素に対応
                    if not submitted:
                        text_variants = ["送信", "送信する", "送る", "確認", "申し込", "お問い合わせ", "Submit", "Send", "Confirm", "Next"]
                        css_templates = [
                            "button:has-text('{t}')",
                            r'input[type="submit"][value*="{t}"]',
                            r'input[type="button"][value*="{t}"]',
                            r'[role="button"]:has-text("{t}")',
                            "a:has-text('{t}')",
                            # ネストされたテキスト要素に対応
                            "button p:has-text('{t}')",
                            "button span:has-text('{t}')",
                            "button div:has-text('{t}')",
                            "[role='button'] p:has-text('{t}')",
                            "[role='button'] span:has-text('{t}')",
                            "[role='button'] div:has-text('{t}')"
                        ]
                        for t in text_variants:
                            for tpl in css_templates:
                                sel = tpl.format(t=t)
                                try:
                                    loc = base.locator(sel)
                                    cnt = await loc.count()
                                    if logger.isEnabledFor(logging.DEBUG) or self.debug:
                                        logger.debug(f"[送信ボタン探索:css] selector={sel} count={cnt}")
                                    if cnt > 0:
                                        # ネストされた要素の場合は親要素（クリック可能な要素）を取得
                                        el = loc.first
                                        try:
                                            # ネストされた要素の場合は親のボタン要素を取得
                                            if ":has-text" in sel and not sel.startswith(("input", "a")):
                                                parent_el = await el.evaluate_handle("el => el.closest('button, [role=button], a[role=button]') || el")
                                                el = parent_el.as_element() if parent_el else el
                                        except Exception:
                                            pass

                                        # ナビゲーションリンクを除外
                                        try:
                                            href = await el.get_attribute("href")
                                            if href and href.startswith("/"):
                                                continue
                                        except Exception:
                                            pass

                                        try:
                                            await el.scroll_into_view_if_needed(timeout=2000)
                                        except Exception:
                                            pass
                                        try:
                                            if self.no_submit:
                                                logger.info("テストモード: 送信ボタンを押さずにスキップ")
                                                submitted = True
                                                self._clicked_submit_selector = f"{sel} (SKIPPED)"
                                            else:
                                                await el.click(timeout=3000)
                                                submitted = True
                                                self._clicked_submit_selector = sel
                                            await page.wait_for_timeout(300)
                                            break
                                        except Exception as e:
                                            if logger.isEnabledFor(logging.DEBUG) or self.debug:
                                                logger.debug(f"[送信ボタンクリック:css] selector={sel} error={e}")
                                except Exception as e:
                                    if logger.isEnabledFor(logging.DEBUG) or self.debug:
                                        logger.debug(f"[送信ボタン探索:css] selector={sel} error={e}")
                            if submitted:
                                break

                    # 3) input/button属性照合（value/inner_textに送信語を含む）- ナビゲーションリンクを除外
                    if not submitted:
                        attr_selectors = [
                            'input[type="submit"]',
                            'input[type="button"]',
                            'button[type="submit"]',
                            'button[type="button"]'
                        ]
                        send_pat = re.compile(r"(送信|送る|確認|submit|send|confirm)", re.I)
                        for sel in attr_selectors:
                            loc = base.locator(sel)
                            cnt = await loc.count()
                            if logger.isEnabledFor(logging.DEBUG) or self.debug:
                                logger.debug(f"[送信ボタン探索:attr] selector={sel} count={cnt}")
                            for i in range(cnt):
                                el = loc.nth(i)
                                try:
                                    # ナビゲーションリンクを除外
                                    href = await el.get_attribute("href")
                                    if href and href.startswith("/"):
                                        continue

                                    val = (await el.get_attribute('value')) or (await el.inner_text())
                                    if val and send_pat.search(val):
                                        try:
                                            await el.scroll_into_view_if_needed(timeout=2000)
                                        except Exception:
                                            pass
                                        try:
                                            if self.no_submit:
                                                logger.info("テストモード: 送信ボタンを押さずにスキップ")
                                                submitted = True
                                                self._clicked_submit_selector = f"{sel} -> {val} (SKIPPED)"
                                            else:
                                                await el.click(timeout=3000)
                                                submitted = True
                                                self._clicked_submit_selector = f"{sel} -> {val}"
                                            await page.wait_for_timeout(300)
                                            break
                                        except Exception as e:
                                            if logger.isEnabledFor(logging.DEBUG) or self.debug:
                                                logger.debug(f"[送信ボタンクリック:attr] selector={sel} error={e}")
                                except Exception:
                                    continue
                            if submitted:
                                break

                    # 4) テキスト直指定→クリック可能祖先へバブル
                    if not submitted:
                        try:
                            tx = page.get_by_text(re.compile(r"(送信|Submit|Send|確認|Next)", re.I))
                            if await tx.count() > 0:
                                node = tx.first
                                # クリック可能祖先
                                handle = await node.evaluate_handle('n => n.closest("button, a, [role=button], [class*=btn], [class*=button], [type=submit], [type=button]") || n')
                                el = handle.as_element() if handle else None
                                if el:
                                    # ナビゲーションリンクを除外
                                    try:
                                        href = await el.get_attribute("href")
                                        if href and href.startswith("/"):
                                            pass  # スキップ
                                        else:
                                            try:
                                                await el.scroll_into_view_if_needed(timeout=2000)
                                            except Exception:
                                                pass
                                            if self.no_submit:
                                                logger.info("テストモード: 送信ボタンを押さずにスキップ")
                                                submitted = True
                                                self._clicked_submit_selector = "text_direct_closest (SKIPPED)"
                                            else:
                                                await el.click(timeout=5000)
                                                submitted = True
                                                self._clicked_submit_selector = "text_direct_closest"
                                            await page.wait_for_timeout(300)
                                    except Exception:
                                        pass
                        except Exception as e:
                            if logger.isEnabledFor(logging.DEBUG) or self.debug:
                                logger.debug(f"[送信ボタン探索:text] error={e}")

                    # 5) 近傍のフォームに対して requestSubmit() を実行（最終手段）
                    if not submitted:
                        try:
                            if active_form_handle:
                                await active_form_handle.evaluate("el => { const f = el.closest('form'); if (f) { (f.requestSubmit ? f.requestSubmit() : f.submit()); } }")
                                submitted = True
                                clicked_submit_selector = "form.requestSubmit() (nearest)"
                                if logger.isEnabledFor(logging.DEBUG) or self.debug:
                                    logger.debug("[送信ボタン] 近傍form.requestSubmit() 実行")
                                await page.wait_for_timeout(300)
                            else:
                                form_el = await page.query_selector('form')
                                if form_el:
                                    try:
                                        await page.evaluate('(f)=>{ if (f.requestSubmit) f.requestSubmit(); else f.submit(); }', form_el)
                                        submitted = True
                                        clicked_submit_selector = "form.requestSubmit() (first)"
                                        if logger.isEnabledFor(logging.DEBUG) or self.debug:
                                            logger.debug("[送信ボタン] 最初のform.requestSubmit() 実行")
                                        await page.wait_for_timeout(300)
                                    except Exception as e:
                                        if logger.isEnabledFor(logging.DEBUG) or self.debug:
                                            logger.debug(f"[送信ボタン] form.submit() フォールバック失敗: {e}")
                        except Exception as e:
                            if logger.isEnabledFor(logging.DEBUG) or self.debug:
                                logger.debug(f"[送信ボタン] requestSubmit フォールバック失敗: {e}")
                    if logger.isEnabledFor(logging.DEBUG) or self.debug:
                        logger.debug(f"[送信クリック] method={self._clicked_submit_selector or 'N/A'}")
                        if not submitted:
                            logger.debug("[送信ボタン] 送信ボタンが見つかりませんでした")
                            # デバッグ用：ページ上の全ボタン要素をログ出力
                            try:
                                all_buttons = await page.query_selector_all('button, input[type="submit"], input[type="button"], [role="button"]')
                                logger.debug(f"[送信ボタン] ページ上のボタン要素数: {len(all_buttons)}")
                                for i, btn in enumerate(all_buttons[:5]):  # 最初の5個のみ
                                    try:
                                        tag = await btn.evaluate('el => el.tagName.toLowerCase()')
                                        text = await btn.inner_text()
                                        href = await btn.get_attribute('href')
                                        logger.debug(f"[送信ボタン] #{i+1}: tag={tag}, text='{text[:20]}', href={href}")
                                    except Exception:
                                        pass
                            except Exception as e:
                                logger.debug(f"[送信ボタン] デバッグ情報取得エラー: {e}")
                    success, note = await self.check_success(page, task.form_url)

                    await browser.close()

                    if success:
                        return FormResult(
                            form_url=task.form_url,
                            status="OK",
                            note=note,
                            timestamp=datetime.now().isoformat(),
                            unmapped_fields=','.join(unmapped) if unmapped else ''
                        )
                    else:
                        return FormResult(
                            form_url=task.form_url,
                            status="SUBMIT_FAIL",
                            note=note,
                            timestamp=datetime.now().isoformat(),
                            unmapped_fields=','.join(unmapped) if unmapped else ''
                        )

            except PlaywrightTimeoutError:
                unmapped = []
                return FormResult(
                    form_url=task.form_url,
                    status="TIMEOUT",
                    note=f"{self.timeout}秒タイムアウト",
                    timestamp=datetime.now().isoformat(),
                    unmapped_fields=','.join(unmapped) if unmapped else ''
                )
            except Exception as e:
                unmapped = []
                return FormResult(
                    form_url=task.form_url,
                    status="ERROR",
                    note=str(e),
                    timestamp=datetime.now().isoformat(),
                    unmapped_fields=','.join(unmapped) if unmapped else ''
                )

    async def save_result(self, result: FormResult, output_file: str):
        try:
            async with self._file_lock:
                async with aiofiles.open(output_file, 'a', newline='', encoding='utf-8') as f:
                    await f.write(f'{result.form_url},{result.status},"{result.note}",{result.timestamp},"{result.unmapped_fields}"\n')
            # 進捗イベントを JSON Lines で出力（--emit-json 時）
            if getattr(self, "emit_json", False):
                try:
                    print(json.dumps({
                        "event": "result",
                        "url": result.form_url,
                        "status": result.status,
                        "note": result.note,
                        "timestamp": result.timestamp,
                        "unmapped": result.unmapped_fields,
                    }), flush=True)
                except Exception:
                    pass
        except Exception as e:
            logger.error(f"結果保存エラー: {e}")

    async def run(self, input_file: str, data_file: str, output_file: str, *, emit_json: bool = False, limit: Optional[int] = None):
        # emit_json フラグをインスタンスにセット（他メソッドで参照）
        self.emit_json = bool(emit_json)
        tasks: List[FormTask] = []
        with open(input_file, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            for i, row in enumerate(reader):
                if 'form_url' not in row:
                    raise ValueError("CSVファイルに 'form_url' 列が必要です")
                tasks.append(FormTask(form_url=row['form_url'], data=row, index=i))
                # Preflight用途：limit 指定があれば先頭N件だけ集める
                if isinstance(limit, int) and limit > 0 and len(tasks) >= limit:
                    break

        with open(data_file, 'r', encoding='utf-8') as f:
            default_data = yaml.safe_load(f) or {}

        async with aiofiles.open(output_file, 'w', newline='', encoding='utf-8') as f:
            await f.write('form_url,status,note,timestamp,unmapped_fields\n')

        queue: asyncio.Queue[FormTask] = asyncio.Queue()
        for task in tasks:
            task.data = {**default_data, **task.data}
            await queue.put(task)

        workers = []
        for _ in range(self.concurrency):
            worker = asyncio.create_task(self._worker(queue, output_file))
            workers.append(worker)

        await queue.join()
        for worker in workers:
            worker.cancel()
        await asyncio.gather(*workers, return_exceptions=True)
        logger.info(f"処理完了: {len(tasks)} 件")

    async def _worker(self, queue: asyncio.Queue, output_file: str):
        while True:
            try:
                task: FormTask = await queue.get()
                result = await self.process_form(task)
                await self.save_result(result, output_file)
                logger.info(f"タスク {task.index + 1} 完了: {result.status}")
                queue.task_done()
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"ワーカーエラー: {e}")
                queue.task_done()

